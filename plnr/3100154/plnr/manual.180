.BSPDIR
.CENTER
Micro-Planner Reference Manual
.CENTER
by
.CENTER
Gerald Jay Sussman, Terry Winograd, and Eugene Charniak
.SP 2
I.   Introduction
.SP
1)  Micro-Planner is an implementation of a subset of 
Carl Hewitt's language, PLANNER, by Gerald Jay Sussman, 
Terry Winograd, and Eugene Charniak on the AI group computer in LISP.
Micro-Planner is now a publicly accessible systems program in the AI group
system ITS.  The current version of Micro-Planner, embedded in an allocated
LISP, may be obtained by incanting ":PLNR" or "PLNR<control-K>" to DDT.
Micro-Planner is also available as EXPR code or LAP code.  All 
questions, suggestions, or comments about Micro-Planner should
be directed to Gerald Jay Sussman (login name GJS) who will maintain the
program.
.BR
.SP
2)  Philosophical Overview
	The "level" of  a programming language is a term which is in fairly 
common usage in the
computer culture.  We all agree, for example, that FORTRAN, LISP,
and PL1 are higher level languages than, say assembly language, regardless
of our opinions of their relative merits for expressing our individual styles of
programming.  After some introspection, I decided that what is meant by the 
level  of a language is the amount of knowledge of programming style implicit 
in the language processor and thus the quantity of detail which the user does
not explicitly have to specify because he may assume that the processor will
fill in for him.  When we express the value judgment that LISP or PL1,
for example, is a lousy language, what we mean is that the stylistic 
assumptions made by the designers of the language are incompatible with our own
styles and thus overly restrict us.  
There are some of us (may ITS preserve their file directories!) with whom
any restrictions are incompatible and who thus always write in assembly language.
There are others, such as I, 
who find such restrictions an aid in the organization
of large programs.  Thus, to me, LISP is useful in that it provides a large
library of subroutines with uniform calling sequences, a convenient evaluator
for defining recursively reentrant procedures from those primitives 
and a bookkeeper for the maintenance of
a list structured data base.  Indeed for these conveniences
I pay heavily in space and time efficiency, 
as well as in some feeling of constrained
style.
	PLANNER is the first of perhaps a whole new level of languages which 
will basically be oriented toward the accomplishment of tasks (or goals) which
may in fact be broken down into subtasks (subgoals).  By contrast, in previous
languages (as LISP) problem solutions are expressed in terms of procedures
(functions).  The distinction is not immediately apparent but should become more
clear if we note that in a PLANNER program, if a goal is activated then
it may be satisfied by any number of objects in the data base or by any number
of theorems (the analogue of procedure).
A backup mechanism is provided
so that one of the possibilities is tried, and then if, as a consequence
a failure occurs, then another is tried, etc.  Furthermore, the data and theorems
need not be referenced explicitly, but rather by saying, in essence, "the datum
(or procedure)" which fits the following pattern (or accomplishes the desired
result).  In order for such data and theorems to be implicitly referenced efficiently
the system has the responsibility of constructing and accessing a cross-referenced
data base of "assertions" (data) and theorems (programs).
.PA
II.  Programming in Micro-Planner
.SP
	The easiest
way to understand Micro-Planner is to watch
how it works, so in this section we will present a few simple
examples and explain the
use of some of its most elementary features.

     First we will take the most
venerable of traditional deductions:
.SP
   Turing is a human
   All humans are fallible
 so
   Turing is fallible.
  
.SP

     It is easy enough to see how this could be
expressed in the usual logical notation
and handled by a uniform proof procedure.
Instead, let us express it in one possible
way to Micro-Planner  by saying:
.SP
 
   (THASSERT (HUMAN TURING))
   (THCONSE (X) (FALLIBLE $?X)
	        (THGOAL (HUMAN $?X)))
 
.SP


     The proof would be
generated by asking Micro-Planner to evaluate the
expression:
.SP
     (THGOAL (FALLIBLE TURING) $T)
.SP
     We immediately see several points.  First,
there are two different ways of storing information.
Simple assertions  are stored in a data base
of assertions, while more complex sentences
containing quantifiers
or logical connectives are expressed in
the form of theorems.
     Second, one of the most important points about
Micro-Planner is that it is an evaluator for statements
written in a programming language.  It
accepts input in the form of expressions
written in the Micro-Planner language, and evaluates
them, producing a value and side effects.
THASSERT is a function which, when evaluated,
stores its argument in the data base of assertions or the data base of theorems
(which are cross-referenced in various ways to give
the system efficient look-up capabilities).
In this
example the second line defines a theorem of the
THCONSE type  (THCONSE means consequent; we will see
other types later).  This states that if we
ever want to establish a goal of the form
(FALLIBLE $?X), we can do this by
accomplishing the goal (HUMAN $?X),
where X is a variable.  Note that
symbols like FALLIBLE and HUMAN have no "meaning"
in Micro Planner.  (All Micro Planner symbols start
with TH .)  Nor is there any significance to
the order in which elements appear in the pattern.
We could have said (TURING IS-AN OSTRICH) for
all Micro Planner cares.  
The strange prefix
characters are part of Micro-Planner's pattern matching
capabilities.  If we ask Micro-Planner to prove a goal
of the form (A X), there is no obvious
way of knowing whether A and X are constants
(like TURING and HUMAN in the
example) or variables.
LISP solves this problem by using the function
QUOTE to indicate constants.  In pattern
matching this is inconvenient and makes most
patterns much bulkier and more difficult to
read.  Instead, Micro-Planner uses the opposite convention --
a constant is represented by the atom itself,
while a variable must be indicated by adding an appropriate
prefix.  This prefix differs according to the
exact use of the variable in the
pattern, but for the time being let us just
accept $?
(this is a dollar-sign -- not an alt-mode)
as a prefix indicating a variable.
The definition of the theorem indicates
that it has one variable, X by
the (X) following THCONSE.
 
     The third statement  illustrates the function
THGOAL, which calls the Micro-Planner interpreter
to try to prove an assertion.  This can function in several ways.
If we had asked Micro-Planner to evaluate
(THGOAL (HUMAN TURING)) it would have found
the requested assertion immediately in the data base and succeeded
(returning as its value some indicator that it had succeeded).
However, (FALLIBLE TURING) has
not been asserted, so we must resort to theorems to prove it.
Later we will see that a THGOAL statement can give Micro-Planner
various kinds of advice on which theorems are applicable to the goal
and should be tried.  For the moment, $T is advice that causes
the evaluator to try all theorems whose
consequent is of a form which matches the goal.
(i.e. a theorem with a consequent ($?Z TURING) would
be tried, but one of the form (HAPPY $?Z) or
(FALLIBLE $?Y $?Z) would not.  If there is no
advice only the data base
will be tried.  Assertions can not
have an arbitrary list structure for their format but they
are not limited to two-member lists or three-member lists as in
these examples.)
The theorem we have just defined would be found, and in
trying it, the match of the consequence to the goal would
cause the variable $?X to be assigned to the constant TURING.
Therefore, the theorem sets up a new goal (HUMAN TURING)
and this succeeds immediately since it is in the data base.  In
general, the success of a theorem will depend on evaluating
a Micro-Planner program of arbitrary complexity.  In this case it contains only
a single THGOAL statement, so its success causes the entire
theorem to succeed, and the goal (FALLIBLE TURING) is
proved.
 
	Consider the question "Is anything fallible?", or in logic
(EXISTS (Y)(FALLIBLE Y)).  This requires a variable and
it could be expressed in Micro-Planner as:
.SP
     (THPROG (Y) (THGOAL (FALLIBLE $?Y) $T) (THRETURN $?Y))
.SP
     Notice that THPROG (Micro-Planner's equivalent of a LISP PROG, complete
with GO statements, tags, RETURN, etc.) acts as
an existential quantifier.
It provides a binding-place for the variable Y,
but does not initialize it -- it leaves
it in a state particularly marked as unassigned.
To answer the question, we ask Micro-Planner to evaluate
the entire THPROG expression above.  To do this it starts
by evaluating the THGOAL expression.  This searches the
data base for an assertion of the form (FALLIBLE $?Y)
and fails.  It then looks for a theorem with a
consequent of that form, and finds the theorem we
defined above. 
Now when the theorem is called, the variable X in the theorem is
identified with the variable Y in the goal, but since Y
has no value yet, X does not receive a value.  The theorem then
sets up the goal (HUMAN $?X) with X as a variable.
The data-base searching mechanism takes this as a command to look for
any assertion which matches that pattern (i.e. an instantiation),
and finds the assertion (HUMAN TURING).
This causes X (and therefore Y) to be assigned to the constant TURING,
and the theorem succeeds, completing the proof and returning the
value TURING.   
     There seems to be something missing.  So far,the data
base has contained only the relevant objects, and therefore Micro-Planner
has found the right assertions immediately.  Consider the
problem we would get if we added new information by evaluating the
statements:
.SP
 
   (THASSERT (HUMAN SOCRATES))
   (THASSERT (GREEK SOCRATES))
   (THASSERT (HUMAN NEWTON))
  
 
.SP

     Our data base now contains the assertions:
.SP
  (HUMAN TURING)
  (HUMAN SOCRATES)
  (GREEK SOCRATES)
  (HUMAN NEWTON)
.SP  
   and the theorem:
.SP  
  (THCONSE (X) (FALLIBLE $?X)
	       (THGOAL (HUMAN $?X)))
.SP
  
     What if we now ask, "Is there a fallible Greek?"
In Micro-Planner we would do this by evaluating the expression:
.sp 
   (THPROG (X) 
	(THGOAL (FALLIBLE $?X)$T)
	(THGOAL (GREEK $?X))
	(THRETURN $?X))
.sp
THPROG acts like an AND, insisting that
all of its terms are satisfied before the THPROG is
happy.  Notice what might happen. 
The first THGOAL may be satisfied by the exact same
deduction as before, since we have not removed information.
Since the data-base searcher will run into NEWTON
before it finds SOCRATES, the goal (HUMAN $?X)
will succeed, assigning $?X to NEWTON.
After (FALLIBLE $?X) succeds,  the THPROG will then
establish the new goal (GREEK NEWTON),
which is doomed to fail since
it has not been asserted, and there are no
applicable theorems.  If we think in LISP terms,
this is a serious problem, since the evaluation of the first THGOAL
has been completed before the second one is called, and the
"push-down list" now contains only the THPROG.  If we try to
go back to the beginning and start over, it will again find NEWTON
and so on, ad infinitum. 
     One of the most important features of the Micro-Planner language is that backup in case
of failure is always possible, and moreover this
backup can go to the last
place where a decision of any sort was made.  Here, the decision was to
pick a particular assertion from the data base to match a goal.
Other decisions might be the choice of a theorem to satisfy
a goal, or a decision of other types found in
more complex Micro-Planner functions.
Micro-Planner keeps
enough information to change any decision and
send evaluation back down a new path.
     In our example the decision was made inside the theorem
for FALLIBLE, when the goal (HUMAN $?X) was
matched to the assertion (HUMAN NEWTON).  Micro-Planner will
retrace its steps, try to find a different assertion which
matches the goal, find
(HUMAN SOCRATES), and continue with the proof.  The
theorem will succeed with the value (FALLIBLE SOCRATES),
and the THPROG will proceed
to the next expression, (THGOAL (GREEK $?X)).
Since X has been assigned to SOCRATES, this will set up
the goal (GREEK SOCRATES) which will succeed immediately
by finding the corresponding assertion in the
data base.
The program will then return the value SOCRATES.
If there were no explicit THRETURN statement, and the
THPROG was allowed to fall off its end, it would return the
default value THNOVAL.
The whole course of the deduction process depends on the
failure mechanism for backing up and trying things over (this
is actually the process of trying different branches down the
subgoal tree.)
All of the functions like THCOND, THAND, THOR, etc. are controlled
by success vs. failure.  Thus it is the Micro-Planner executive
which establishes and manipulates subgoals in looking for a proof.

     Although Micro-Planner is 
written as a programming language, it differs in several critical
ways from anything
which is normally considered a
programming language.  First, it is goal-directed.
Theorems can be thought of as subroutines, but they can be called
by specifying the goal which is to be satisfied.  This is like having
the ability to say "Call a subroutine which will achieve the desired
result at this point."  Second, the evaluator has the mechanism of
success and failure to handle the exploration of the subgoal tree.
Other evaluators, such as LISP, with a basic recursive
evaluator have no way to do this.  Third, Micro-Planner contains a 
bookkeeping system for matching patterns
and manipulating a data base, and for handling that data base efficiently.

     How is Micro-Planner different from a theorem prover?
What is gained by writing theorems in the form
of programs, and giving them power to call other programs which manipulate
data?  The key is in the form of the data the theorem-prover can
accept.  Most systems take declarative___________
information, as in predicate calculus.  This is in the form of expressions
which represent "facts" about the world.  These are manipulated
by the theorem-prover
according to some fixed uniform process set by the system.
Micro-Planner can make use of imperative__________ information,
telling it how to go about proving a subgoal, or to make use of an
assertion.  This produces what is called 
hierarchical____________
control_______
structure_________.
That is, any theorem can indicate what the theorem prover is supposed
to do as it continues the proof.  It has the full power of
a general programming language to evaluate functions which can
depend on both the data base and the subgoal tree,
and to use its results to control the further proof by
making assertions, deciding what theorems are to be used, and
specifying a sequence of steps to be followed.
What does this mean in practical terms?  In what way does it make
a "better" theorem prover?  We will give several 
examples of areas where the approach is important.

     First, consider the basic problem of deciding what subgoals
to try  in attempting to satisfy a goal.  Very often, knowledge of
the subject matter will tell us that certain methods are very likely to
succeed, others may be useful if certain other conditions are present,
while others may be possibly valuable, but not likely.  We would like
to have the ability to use heuristic programs to determine these facts
and direct the theorem prover accordingly.  It should be able to
direct the search for goals and solutions in the
best way possible, and
able to bring as much intelligence as possible to bear
on the decision.  In Micro-Planner this is done by adding to our THGOAL statement a
recommendation______________
list____
which can specify that ONLY certain theorems are to be tried, or
that certain ones are to be tried FIRST in a specified order.
Since theorems are programs, subroutines of any type can be called to
help make this decision before establishing a new THGOAL.
A theorem can be given a name
so that it can be explicitly referred to.  In
our example, however, we did not do so.  If we had
wanted to name it, say, FALLIBLE-PROVER, we would have written
.sp 

	(THCONSE FALLIBLE-PROVER (X)  ... )
.sp 

     An important problem is
that of maintaining a data base with a reasonable amount
of material.  Consider the first example above.  The statement
that all humans are fallible, while unambiguous in a declarative
sense is actually ambiguous in its imperative sense (i.e. the
way it is to be used by the theorem prover).  The first way is to
simply use it whenever we are faced with the need to prove
(FALLIBLE $?X).  Another way might be to
watch for a statement of the form (HUMAN $?X) to be
asserted, and to immediately assert (FALLIBLE $?X) as well. 
There is no abstract logical difference, but the impact on the
data base is tremendous.  The more conclusions
we draw when information is asserted, the easier proofs will be,
since they will not have to make the additional steps to deduce these
consequences over and over again.  However since we don't have
infinite speed and size, it is clearly folly to think of deducing
and asserting everything possible (or even everything
interesting) about the data when it is entered.  If we were working with
totally abstract, meaningless theorems and axioms (an
assumption which would not be incompatible with many theorem-proving
schemes), this would be an insolvable dilemma.
But Micro-Planner is designed to work in the real world,
where our knowledge is much more structured than a set of axioms
and rules of inference.
We may very well, when we assert (LIKES $?X POETRY)  want to deduce and
assert (HUMAN $?X), since in deducing things about
an object, it will very often be relevant whether that object is
human, and we shouldn't need to deduce it each time.  On
the other hand, it would be silly to assert (HAS-AS-PART $?X SPLEEN),
since there is a horde of facts equally important and equally limited in use.
Part of the knowledge which Micro-Planner should have of a subject, then,
is what facts are
important, and when to draw consequences of an assertion.
This is done by having theorems of an antecedent type:
.SP
 
(THANTE (X Y) (LIKES $?X $?Y)
	      (THASSERT (HUMAN $?X)))
 
.SP


     This says that when we assert that X likes something,
we should also assert (HUMAN $?X). Of course, such theorems
do not have to be so simple.  A fully general Micro-Planner program
can be activated by an THANTE
theorem, doing an arbitrary (that is, the programmer has free choice)
amount of deduction, assertion, etc.  Knowledge of what
we are doing in a particular problem may
indicate that it is sometimes a good idea to do this kind of
deduction, and other times not.  As with the consequent
theorems, Micro-Planner has the full capacity when something is asserted,
to evaluate the current state of the data and proof, and
specifically decide which antecedent theorems should
be called.
     Micro-Planner therefore allows deductions to use all sorts
of knowledge about the subject matter which go far beyond the set
of axioms and basic deductive rules. Micro-Planner itself is subject-independent,
but its power is that
the deduction processs never needs to operate on such a
level of ignorance.  The programmer can put in as much heuristic knowledge
as he wants to about the subject, just as a good teacher would
help a class to understand a mathematical theory, rather than just
telling them the axioms and then giving theorems to prove.


     Another advantage in representing knowledge in an imperative
form is the use of a theorem prover in dealing
with processes involving a sequence of events.  Consider the case
of a robot manipulating blocks on a table.  It might
have data of the form, "block1 is on block2," "block2 is behind block3",
and "if x is on y and you put it on z, then x is on z, and is no longer on
y unless y is the same as z".  Many examples in papers on theorem
provers are of this form (for example the classic "monkey
and bananas" problem).  The problem is that a declarative theorem prover
cannot accept a statement like (ON B1 B2) at face value.  It
clearly is not an axiom of the system, since its validity will change
as the process goes on.  It must be put in a form (ON B1 B2 S0)
where S0 is a symbol for an initial state of the world.  The third
statement might be expressed as:

.SP
(FORALL (X Y Z S)(AND (ON X Y (PUT X Y S))
                      (OR(EQUAL Y Z)
                         (NOT(ON X Z (PUT X Y S))))))

.SP
  
     In this representation, PUT is a function whose
value is the state which results from putting X on Y when the previous state
was S.
We run into a problem when we try to ask (ON Z W (PUT X Y S))  i.e. is
block Z on block W after we put X on Y? 
A human knows that if we haven't touched Z or W
we could just ask (ON Z W S) but in general it may take a complex
deduction to decide whether we have actually moved
them, and even if we haven't, it will take a whole
chain of deductions (tracing back through the time sequence)
to prove they haven't been moved.  In Micro-Planner, where
we specify a process directly, this whole type of problem can be handled
in an intuitively more satisfactory way by using the primitive function
THERASE.
     Evaluating (THERASE (ON $?X $?Y)) removes
the assertion (ON $?X $?Y) from the data base.  If we think
of theorem provers as working with a set of axioms, it
seems strange to have a function whose purpose is to erase axioms.
If instead we think of the data base as the "state of the world" and the
operation
of the prover as manipulating that state, it allows
us to make great simplifications. Now we can simply assert (ON B1 B2) without
any explicit mention of states.  We can express the necessary theorem
as:
.SP 

  (THCONSE (X Y Z) 
	   (PUT $?X $?Y)
           (THGOAL (ON $?X $?Z))
           (THERASE (ON $?X $?Z))
           (THASSERT (ON $?X $?Y)))
  
 
.SP
      This says that whenever we want to satisfy a goal of the
form (PUT $?X $?Y), we should first find out
what thing Z the thing X is sitting on, erase the fact that
it is sitting on Z, and assert that it is sitting on Y.
We could also do a number of other things, such as proving that
it is indeed possible to put X on Y, or adding a list of specific
instructions to a movement plan for an arm to actually execute
the goal.  In a more complex case, other
interactions might be involved.  For example, if we
are keeping assertions of the form (ABOVE $?X $?Y)
we would need to delete those assertions which
became false when we erased (ON $?X $?Z) and add those
which became true when we added (ON $?X $?Y).
Antecedent theorems could be called by the assertion
(ON $?X $?Y) to take care of that part, and a similar
group called erasing theorems can be called in
an exactly analogous way when an assertion is erased,
to derive consequences of the erasure.  Again we emphasize,
which theorems will be called can be made dependent on the
way the data base is structured, which in turn can reflect knowledge of the
subject matter.  In this example, we would have to decide whether it
was worth adding all of the above relations to the data base,
with the resultant need to check them whenever something is
moved, or instead to omit them and take
time to deduce them from the ON relation each time they are needed.
     Thus in Micro-Planner, the changing state of the world can be mirrored in the
changing state of the data base, avoiding any need to make
explicit mention of states, with the requisite overhead
of deductions.  This is possible since the information
is given in an imperative form, specifying theorems as
a series of specific steps to be executed.
     If we look back to the distinction between assertions and
theorems made on the first page, it would seem that we have
established that the base of assertions is the
"current state of the world", while the base
of theorems is our permanent knowledge of how
to deduce things from that state.
This is not exactly true, and one of the most
exciting possibilities in Micro-Planner is the capability for
the program itself to create and modify the Micro-Planner functions
which make up the theorem base.  Rather than simply
making assertions, a particular Micro-Planner function might
be written to put together a new
theorem or make changes to an
existing theorem, in a way dependent
on the data and current knowledge.  It seems
likely that meaningful "learning" involves this
type of behavior rather than simply modifying parameters
or adding more individual facts (assertions) to a declarative
data base.


 
.PA

III.  The Micro-Planner Primitives 
.sp
	This section will basically be a list of the Micro-Planner
primitives with a detailed description of each.
Meta-Linguistic variables will be enclosed in angle brackets
(<>).   
	The heart of Micro-Planner is a structure known as THTREE; it is
to the hierarchical control structure of PLANNER what a push-down list is
to a recursive control structure such as is found in LISP.  In LISP the
push-down list remembers the return addresses of recursive function
calls; in Micro-Planner THTREE keeps track of the decisions (or
hypotheses) made so far in the problem-solving process which are currently 
considered
relevant to the solution.  In case a failure occurs PLANNER can back up
THTREE, undoing the decisions which caused the failure until a 
promising approach is found.  If none is found the program returns a failure.
THTREE is a tree structure, each node of which contains
information about how to proceed in case either success or failure
propagates to that node.  Failure is propagated from a node if and only if
a failure propagates to it and no further possibilities exist at that node.
A node of THTREE may be thought of as a goal, with branches originating
at this node associated with tentatively useful hypotheses for establishing 
the goal.
   Closely associated with THTREE is THALIST, the list of variable
bindings.  Certain primitives bind variables by declaration.  In their
initial bound state variables are called unassigned and are assigned to
"THUNASSIGNED."  THALIST shares the tree structure of THTREE.  
	Because of the non-recursive implementation of the Micro-Planner interpreter
the PLANNER value of an expression is not the same as its LISP value.
In most cases this is unimportant because PLANNER expressions are usually
executed for effect rather than for value.  The PLANNER value of an 
expression is however available as the LISP value of the LISP free
variable THVALUE immediately after the expression is executed.  Although
this is not a very pretty convention it introduces some very great simplifications
in the implementation.
.SP

1)  .PLNR. (INIT)
	One can have a PLANNER INIT file in the same
way one has a teco init file.  The file name should be as above.
.sp 


2)  (THAMONG <variable name> <expression>) 
   Upon entry the variable named (by an atom) must be bound.  If it is
unassigned then it will be assigned to the first member of the list of
choices to which <expression> THVALuates.  If the variable already has a
value (is assigned), THAMONG fails unless 
the assigned value is already among the
choices.  Each time a failure backs up to the THAMONG the variable will
be assigned to the next element of the choice list.  If it runs out of
choices it fails, otherwise it succeeds.  
.SP
3)  (THAND <e1> ... <en>) 
   THAND fails unless each of its subexpressions succeeds in sequence,
allowing for backup.  It is just like THPROG except that there are no
variable declarations or tags allowed.  
.SP
4)  (THANTE <thm-name> <list-of-variables> <pattern> <body>)
	THANTE works in a similar fashion to THCONSE to define and
(optionally) assert antecedent theorems.
.SP
5)  (THAPPLY <theorem> <datum>)  calls the specified theorem causing it
to match its pattern to the specified datum.  If it matches, the theorem
is executed with <datum> as its "argument."  The THVALUE of a THAPPLY is
the value of the theorem applied.
 
.SP
6)  (THASSERT <skeleton> <rec1> ... <recn>) 
   THASSERT adds the assertion (formed by substituting assignments for
variables
(or by THVALing $E's as described in the matcher section)
in the skeleton) to the data-base except if the skeleton is an
atom, in which case it adds the atom as a theorem to the theorem base.  
   THASSERT only fails if it tries to assert an already existing
assertion.   If the first recommendation to a THASSERT is a (THPROP <e>)
then the LISP value of <e> is used as the property list of the assertion
being asserted.  A more complex
recommendation is THPSEUDO, which has its own listing.  THASSERT
also may recommend antecedent theorems with
THTBF or THUSE as in THGOAL, though the success or failure of those
theorems is irrelevant to success or failure of the assertion.  
The PLANNER value of a THASSERT is the object asserted.
.SP
7)  (THASVAL <variable>) 
   THASVAL is a predicate which assumes that the indicated variable is
bound.  It succeeds if and only if the variable is assigned a value.  
.SP
8) (THBKPT <comment>)
	THBKPT has no effect unless traced. If it is, its comment is


printed.  If the trace's break predicate is true as well, e. g. 
	(THTRACE (THBKPT T T)), 
.BR
then THBKPT breaks in a similar fashion to THERT. (see ***).
However, THBKPT is more powerful than THERT as it also breaks upon
failure backing up to it.  It is thus more useful than THERT for
debugging PLANNER programs. 
.SP
9)  (THCOND <pair1> ... <pair n>) 
   THCOND is the PLANNER analogue of COND in LISP.  As in MAC-LISP the
"pairs" needn't be.  Basically THCOND executes the CAR of each pair until
one succeeds.  The THCOND will then succeed if all the rest of that
"pair" succeeds (like a THAND) else THCOND will fail.  

.SP
10) (THCONSE <thm-name> <list-of-variables> <pattern> <body>)
	A planner consequent theorem can be defined and asserted by
the function THCONSE.  For example,  a consequent theorem named THM1
can be defined and asserted as follows: 
.SP
	(THCONSE THM1 (X) (FALLIBLE $?X) (THGOAL (HUMAN $?X)))
.SP
This is equivalent to:  
.SP
	(THPUTPROP 
		'THM1 
		'(THCONSE (X) (FALLIBLE $?X) (THGOAL (HUMAN $?X)))
		'THEOREM)
	(THASSERT THM1) 
.SP
	The theorem name is optional.  If it is not given, a unique
name is generated by the system.  Note that this feature should not
be used if one later wants to erase the theorem.
	Asserting the theorem can be avoided by placing THNOASSERT
immediately after the theorem name  For example,
.sp
 (THCONSE THM1 THNOASSERT (X) (FALLIBLE $?X) (THGOAL (HUMAN $?X)))
.sp
will define THM1, but not assert it.
.SP
11)  (THDATA) causes Micro-Planner to go into a read loop for gobbling
assertions and theorems at high speed.  Loop ends when NIL is read.  
.SP
12)  (THDO <e1> ... <en>) 
   THDO executes each of its subexpressions in turn and cares not whether
they succeed or fail; it then succeeds.  More
precisely, it only ignores simple failures occurring in its
scope.  (For the distinction between types of failures,
see THFAIL.)
If a failure backs up to it, all
that it did is undone.  
.SP
13) (THDUMP <filename1> <filename2> <device> <user>)
	Dumps the state of the Micro-Planner world (THSTATE) into
the specified file.
	(THDUMP SAVE STATE) (THFLUSH) (UREAD) (IOC Q)
.BR
is a no op.
.sp 2
14)  THEOREMS 
   Theorems are the Micro-Planner analogue of functions in LISP.  There
are three kinds:  
.sp
   consequent theorem - for establishing goals 
   antecedent theorems - for expanding on assertions 
   erasing theorems - for expanding on erasures.  
.sp
See THCONSE, THERASING, and THANTE for a convenient
method of defining theorems.  When a theorem is called the declared
variables are bound and the pattern is matched to the calling pattern in
THGOAL or datum in THASSERT, THERASE, and THAPPLY.  This has the effect
of assigning some of the theorem's variables.  The theorem is then
executed as a THPROG if the match succeeds.  
.SP

15)  (THERASE <skeleton> <rec1> ... <recn>)  is identical to THASSERT
except for effect.  If a failure backs up to an assertion or an erasure
it is undone.  
.SP
16)  (THERASING <thm-name> <list-of-variables> <pattern> <body>) 
	THERASING works in a similar fashion to THCONSE to define
and (optionally) assert antecedent theorems.
.SP
17) (THERT <comment>)
	THERT causes Micro-Planner to break and print its comment.
The state of the world can be explored by EVALing any s-expression.
Planner expressions can be thvaled by explicitly calling thval.  For
example,
	(THVAL (THASSERT (HUMAN TURING))  NIL)
.BR
would add this assertion to the data base if it had not been
previously asserted.  Note that explicit thvals should be done
carefully as they can change the state of the world.
	When ready to leave the breakpoint, ($P <s-exp>) causes
THERT to return the lisp value of the s-exp, (where "$" = ALT-MODE).
Note that this will cause failure if the expression evals to NIL. $P
is equivalent to ($P T) and is the standard way to proceed from the
breakpoint.
.SP
18)  (THFAIL <arg1> <arg2> <arg3>) 
   THFAIL causes failure to propagate, the extent of which is determined
by the arguments:  
   (THFAIL THTAG <tag> T) causes a failure to propagate to the tag
indicated.   
   (THFAIL THTAG <tag>) causes a failure to propagate past the tag
indicated.   
   (THFAIL THPROG), (THFAIL THEOREM) cause the THPROG or the THEOREM
currently in to fail.  
   (THFAIL THMESSAGE <message>) causes a failure to propagate 
until it reaches a THMESSAGE statement whose pattern matches the message.
   (THFAIL)  causes a failure similar to the one caused by a THGOAL, say, failing.  
The program will back up to the last decision point and
try to patch things up. 
	Any failure caused by THFAIL, except
when it is given no arguments, is a compound failure.  All other
failures are simple failures.
.SP
19) (THFAIL? <predicate> <action>)
	If failure backs up to this planner primitive and the LISP
predicate evals to true, it returns the eval of the action.  THFAIL?
is useful as a computationally less costly form of THMESSAGE since
it does not involve pattern matching against a message failure or
THPROGing.
.SP
20)  (THFINALIZE <arg1> <arg2>) 
   THFINALIZE is a primitive which allows pruning of THTREE.
Essentially, if one THFINALIZES, say to a tag, then all the things done
since that tag was passed are not undoable in case of failure.  Example:
To put all of the green blocks in the box and return a list of those
actually moved:  
.NF

   (THPROG (X (Y NIL))
      (THOR (THAND (THGOAL (IS $?X BLOCK))
		   (THGOAL (COLOR $?X GREEN)))
	    (THRETURN $?Y))
      FOO
      (THCOND ((THGOAL (CONTAIN BOX $?X)) (THFAIL))
	      ((THGOAL (PUTIN $?X BOX) (THUSE TC-PUTIN))
	       (THSETQ $?Y (CONS $?X $?Y))
	       (THFINALIZE THTAG FOO)
	       (THFAIL))
	      ((PRINT $?X) (THERT CAN NOT PUT IT IN))))

.FI
   Besides finalizing to a tag, one can finalize a theorem or a THPROG by
saying (THFINALIZE THEOREM) or (THFINALIZE THPROG).  There are lots of
other things that can be done with THFINALIZE, but I will not guarantee
them.  
.SP
21)  (THFIND <mode> <skeleton> <variable declarations> <e1> ... <en>) 
   THFIND is a primitive whose THVALuation yields a list of objects, each
of which is the result of substituting for variables in the skeleton
values of those variables which cause the program starting at the
variable declarations (like a THPROG) to succeed.  Thus, for example, if the
data-base contained the assertions (HACKER N) (HACKER H) (HACKER RG) (AT
MAC RG) and we THVALed the expression (THFIND ALL (AT SC $?X) (X) (THGOAL
(HACKER $?X)) (THNOT (THGOAL (AT MAC $?X)))) we would get ((AT SC N) (AT
SC H)) as its THVALUE (PLANNER value).
	The mode field of a THFIND may be any of the following.
.sp
	ALL  Says to find all items matching the description
<number> Find at least that number, there may be more
in the data base, but I am not interested in them.
	(EXACTLY <number>)  I want this number, if there are any more, fail.
	(AT-LEAST <number>)  If there are fewer, fail, there may be more.
	(AT-MOST <number>)  There may be less, but if there are more, fail.
	(AS-MANY-AS <number>)  I don't care how many there are (providing there is at least 1), but I only want to see <number> of them.
	(AT-LEAST <number1> AT-MOST <number2>)  Takes the logical "and" of the two conditions
	(AT-LEAST <number1> AS-MANY-AS <number2>)  Same here.
.sp
Those familiar with the old version might note that
this is a different syntax.  However, any code writen in the old form
will still work on the new system. 
.SP
22)  (THFLUSH <indicator1> <indicator2> ...) 
   THFLUSH is a generally useful function for getting a LISP into some
desired state.  It remprop's all properties with the indicators specified
from all atoms on the OBLIST.  
	(THFLUSH) = (THFLUSH THASSERTION THANTE THCONSE THERASING)
.SP
23)  (THGO <tag>) = (THSUCCEED THTAG <tag>) 
.SP
24)  (THGOAL <pattern> <rec1> ... <recn>) 
   This is a real dilly to describe.  It is probably the most complex
single primitive in Micro-Planner.
Assume the simplest case in which there are no recommendations
<reci> given.  THGOAL searches the data base for a datum (i.e. an
assertion) which matches the pattern.  If it finds one, it succeeds after
assigning all of the unassigned variables in the pattern so as to make it
match the datum;  it then returns the assertion found as its PLANNER 
value.  If
it does not find a matching datum it fails.  If after a success, a
failure propagates back to it, it unassigns the variables it assigned
last time and continues its search for a matching datum from where it
left off.  
   If recommendations are given they are tried in order.  If the very
first recommendation is a (THNODB) or a (THDBF -) the initial data base


search is inhibited, otherwise it is assumed in default.  The possible
recommendations are:  
     1) (THNODB) - Inhibit data base search.  If it is not first, it is
useless and causes an error.  
     2) (THDBF <filter>) -  Try only those elements of the data base
satisfying the filter.  
     3) (THTBF <filter>) - Try only those theorems satisfying the
filter.   
     4) (THUSE <th1> <th2> ...<thn>) - Try the theorems given explicitly
by their atom headers in the order mentioned.  
   A filter is any unary LISP predicate;  the always true predicate is
supplied by the system as THTRUE.  All assertions have property lists
which are their CDRs.  Thus if a filter refers to the CDR of its argument
it is referring to the property list.  CAR of an assertion, however, is
not -1 as in LISP atoms;  rather it is the datum which is matched against
the pattern.  
   If a theorem is recommended, say with THUSE, it had better be an atom
with a THEOREM property pointing to a consequent theorem (i.e. it must be
of the form (THCONSE <variable declarations> <consequent> <e1> ...
<en>)).  Note that the theorem
need not be asserted for THUSE to apply.  
If the goal pattern matches the consequent, then the theorem
will be tried.  The matcher will first bind the theorem variables 
appearing in the declaration (see THPROG) and then match the patterns,
causing some of the theorem variables to be assigned and leaving others
unassigned.  If the match wins, the theorem will proceed to execute as a
THPROG.  If the theorem succeeds the PLANNER value
of the THGOAL will be the pattern of the goal with the assignments substituted
for the assigned variables, unless the theorem does a THRETURN, in which
case the PLANNER value of the THGOAL will be the goodie returned.
If a goal variable which is unassigned is matched against a
theorem variable and the theorem eventually gives that variable a value
then the goal variable also gets the value.  A more detailed description
of the matcher will be given later.  
	5)  $N <number> is a macro for (THANUM <number>).  It
says that the goal should only
be tried to be satisfied <number> times.  Hence
the <number> + 1 'th time the goal is failed
back to, no more attempts will be made
and the failure will continue backwards.  In particular, $N1
can be used when there is only one possible answer, and if failure
backs up to the THGOAL, no good can come by trying
different assertions or theorems.  $N <number>, if it is to
appear at all, must appear in the first position.  
	6)  (THNUM <number>) is very similar to $N <number>, but
may appear at any point in the recommendation list.  Its effect
is to set or reset the number of times the goal will be tried. 
For example, if it should appear first in the list, it is, in
effect saying, the goal may use any number of assertions
it can find, but only <number> number of theorems.  In general,
by interspersing THNUM's between recommendations, you are saying
how many of the theorems which match the next filter can be
tried. 

.SP
25) (THMATCH <exp1> <exp2>)
	THMATCH matches the lisp value of its first argument against
the lisp value of its second argument.  For example,
	(THMATCH '(HUMAN TURING) '($_X $_Y))
.BR
would succeed and result in $_X being assigned to 'HUMAN and $_Y being
assigned to 'TURING.  If $_X were instead $?X, then THMATCH would
succeed with $?X assigned to 'HUMAN, providing $?X were previously


either THUNASSIGNED or assigned to HUMAN.
	Failing back through a THMATCH is similar to failing back
through a THGOAL.  Any variable assignments made by the match are
undone and the variables are returned to their previous values. 
	Note that THMATCH will not work properly if its inputs are
themselves planner functions since PLANNER is not corecursive with
LISP.  For example, if HUMAN TURING is already asserted, the planner
value of
.sp
	(THGOAL (HUMAN TURING)) 
.sp
is ((HUMAN TURING)) but its lisp value is NIL.  Hence,
.sp
	(THMATCH (THGOAL (H T)) '(HUMAN TURING))
.sp
will not work properly.  An explicit call to THVAL, however, will
work:   
.sp
	(THMATCH 
		(THVAL '(THGOAL (HUMAN TURING)) NIL) 
		'((HUMAN TURING)))
.SP
26)   (THMESSAGE <variable declarations> <pattern> <e1> . . . <en>)
examines failures propagating to it, if one has a message which matches the pattern
(after the declarations are made) control then passes to the body, <ei>, which
executes as a THPROG.
.SP
27) (THNOHASH <ATOM> <INDICATOR1> <INDICATOR2>... )
	The patterns of micro-planner theorems and assertions are
stored in buckets hung on the atoms appearing in the patterns.
Atoms which are very common are not very useful for this purpose.
For example, suppose we wished to assert the following five
patterns:
.SP
	A1: (JOHN IS A BOY)
	A2: (JACK IS A BOY)
	A3: (MARY IS A GIRL)
	A4: (JILL IS A GIRL)
	A5: (WOOF IS A DOG)


.SP
"IS" and "A" are not helpful in distinguishing any of these
assertions from the others.  It would save space as well as
computation to tell planner this.  Executing
.sp
	(THNOHASH IS THASSERTION)
	(THNOHASH A  THASSERTION)
.sp
accomplishes this purpose.
	One can be selective in telling planner where a particular
atom is not useful for pattern matching purposes.  This is done by
specifying which of the four following types of patterns the atom is
not useful in indexing: 
	the patterns of 
.sp
		consequent theorems
		antecedent theorems
		erasing theorems
		assertions.
.sp
The syntax for this is to use any combination of the four following
indicators:
.sp
	THCONSE, THANTE, THERASING, THASSERTION 
.SP
	For example, (THNOHASH IS THASSERTION) informs planner not
to use the atom "IS" as a handle on the pattern matching of
assertions in which it is found.  It is still used for pattern
matching purposes when it occurs in the patterns of theorems.
.SP
	(THNOHASH <atom> THCONSE THANTE THERASING THASSERTION)
.sp
can
be abbreviated as (THNOHASH <atom>) and is used when the atom that
it is completely useless for pattern matching purposes. 
.SP
28)  (THNOT <e>)  is defined as  (THCOND (<e> (THFAIL)) ((THSUCCEED))).  
.SP
29)  (THOR <e1> ... <en>) 
   THOR succeeds if at least one of its subexpressions succeeds.
Basically, it CDRs down the list looking for a winner and if it finds one
it succeeds, returning its value as the PLANNER value.  If a failure propagates
back to it, however, it continues CDRing from the point it left off until
it finds another winner or it loses.  
.SP
30)  (THPROG <declaration> <e1> ... <en>) 
   THPROG is the PLANNER equivalent of the LISP function PROG.  Its job
is to bind the variables mentioned in the declaration and then to execute
the expressions <ei> in sequence, unless changes in sequence are
specified by tags and THGO statements.  As in LISP, atoms occurring in
THPROG bodies are interpreted as tags.  If (THGO <tag>) is executed at
any point in the interpretation of a THPROG, execution then proceeds from
the expression immediately following the tag <tag>.  THGO statements may
refer to tags which are not in the current THPROG but which are in one
which called it.  The execution of THPROG terminates either with a
failure, successful execution of its last expression, <en>, or by a
forced success with a THRETURN statement.  (THRETURN <exp>) is equivalent
to 
(THSUCCEED THPROG <exp>) and will cause the THPROG to succeed and return
as its PLANNER 
value the LISP value of the indicated expression.  If a THPROG
returns by succeeding past the last statement, or by executing a 
(THSUCCEED THPROG),
it returns as its
PLANNER value the atom THNOVAL.  If it fails, it returns NIL.  
   The <declaration> is a list of variable declarations.  A
variable declaration is either an atom which is the name of a variable to
be used inside the THPROG, or a list of two elements, the first of which
is the variable name and the second of which is a LISP expression whose
LISP value is to be used as the initial value of the variable.  If a variable
is bound without giving it an initial value it is given the default value
"THUNASSIGNED."  A more complex form of variable declaration may be found under THRESTRICT. 
   Evaluation of a THPROG begins at the first expression of the indicated
sequence.  If it succeeds, a new branch is generated on THTREE and the
next expression in sequence is evaluated, etc.  If any statement fails
then the branches are unwound until either a new success ends the failure




propagation or there are no more branches and the THPROG fails.  Thus
THPROG behaves as a THAND with variable binding capability;  it fails
unless each of its subexpressions succeeds, allowing for backup, until it
returns.  As usual, any LISP expression may appear in a THPROG;  if it
evaluates to NIL, a failure is generated, otherwise a success is assumed.
Other relevant functions are THSUCCEED, THFAIL, THFINALIZE, THGO, and
THRETURN.   
.SP
31) THPSEUDO
	"(THPSEUDO)" as the first recommendation to an assertion
enables one to activate a pattern's antecedent theorems, without
actually asserting the pattern.  For example, to activate the
antecedent theorems which match the pattern "(HUMAN TURING)" without
actually asserting it is accomplished by:
.sp
	(THASSERT (HUMAN TURING) (THPSEUDO) $T) 
.sp
In many cases this can be done without using THPSEUDO by first
asserting the pattern with the appropriate theorem recommendations


and then erasing the pattern.  For instance, one could accomplish
the same effect as using THPSEUDO  in the above example by the
following:
.SP
	(THASSERT (HUMAN TURING) $T)
	(THERASE (HUMAN TURING))
.SP
However, THPSEUDO becomes necessary when some of the variables in
the pattern are unassigned, thus preventing it from being asserted.
	THPSEUDO performs in the same fashion for activating a
pattern's erasing theorems  without actually erasing the pattern.
.sp
32)  THPUTPROP, THREMPROP, THRPLACA, THRPLACD  are just like their LISP
counterparts except that if a failure backs up to them they undo their
effect.   
.SP
33) (THRESTRICT <variable> <lisp function 1> <lisp function 2> ...)
	THRESTRICT allows one to restrict a PLANNER variable so that
it will only match objects which satisfy the LISP predicates named in
the THRESTRICT statement.  For example, consider
.sp
	(THGOAL (AGE MOTHER ($R $?X NUMBERP)))
.sp
$R is an abbreviation, which expands to THRESTRICT. In this example,
$?X will only match numbers.  Naturally, the function named must be
a function of one variable.  Of course, we could have a lambda
expression instead of the function name, as in
.sp
(THGOAL ($?Y IS A ($R ? (LAMBDA (X) (MEMQ X '(DOG CAT HACKER))))))
.sp
Also note that rather than a variable, we have a question mark
inside the $R expression.  The net result is that the "?" will only
match DOG, CAT, or HACKER.  However, it doesn't get assigned a value
as $?X would in our first example.  We can also have
.sp
	($R $_Z MYPRED) 
.sp
which has the expected result.  
		In all our examples so far the restriction has been
declared in our goal statement.  We can also create the restriction
when we declare variables at the begining of a theorem, or a THPROG,
as in
.sp
	(THPROG (A ($R B HUMANP)C)
		(THGOAL ($?A SON OF $?B) $T))
		...) 
.sp
In this THPROG's variable bindings we use B
rather than $?B or $_B.  (The prefix would have no meaning in the
context of a variable list.) It is also possible to use THRESTRICT
as a free standing function, so this last THPROG could have been
written 
.sp
	(THPROG (A B C) 
		(THRESTRICT B HUMANP)
		(THGOAL ($?A SON OF $B)$T)
		...)
.sp
	Once we restrict a variable it stays restricted until it
is unbound. As we shall see,
this has some interesting consequences. 
	At the moment THGOAL is the only function which takes note
of restrictions. So one can THSETQ a restricted variable to a value
which would not satisfy its restrictions.  The same goes for
THAMONG.
	It is possible to have
.sp
	(THPROG (A ($R B ORANGEP) C)
		(THGOAL (OWN $?A ($R $?B CIRCULARP)))
		...)
.sp
which will act the same as
.sp
	(THPROG (A ($R B ORANGEP CIRCULARP) C)
		(THGOAL (OWN $?A $?B))
		...)
.sp
Another interesting case is
.sp
	(THGOAL (OWN JACK ($R $?B CIRCULARP)) (THUSE WHOHAS))
.sp
where WHOHAS looks like 
.sp
	(THCONSE (F G)
		(OWN $?F $?G)
		(THGOAL (HOLD $?F ($R $?G SMALLP))$T))
.sp
When we do this last THGOAL, the item which matches $?G must satisfy
both CIRCULARP and SMALLP.  It is possible that this goal will call
another theorem which satisfies the goal without assigning $?G a
value.  If this is the case then our first goal (OWN JACK...) will
be satisfied without B getting a value, but, the restriction SMALLP
will stay with $?B, just as an assigned value would have.  Hence it
is possible for a theorem not to assign a value to a variable, but
merely restrict its range of possibilities.
.SP 
34)  (THRETURN <e>) = (THSUCCEED THPROG <e>) 
.SP
35)  (THSETQ <var1> <e1> ... <varn> <en>) 
      Sets variable 1 to the value of e1 and ... and sets variable n to
the value of en.  If failure backs up to it, it is undone.  If the variable is a
planner variable then the corresponding expression is THVALed;  otherwise
the expression is EVALed.  THSETQ ignores
variable restrictions.  See warning about THVAL.  
.SP
36) (THSTATE <indicator1> <indicator2> ... )
	Prints that part of the state of the Micro-Planner world
specified by the indicators.
	(THSTATE THASSERTION) = assertions in data base 
	(THSTATE THCONSE) = consequent theorems currently asserted
	(THSTATE THANTE) = antecedent theorems currently asserted
	(THSTATE THERASING) = erasing theorems currently asserted
.sp 
37)  (THSUCCEED <arg1> <arg2>) 
   THSUCCEED caused success to propagate, the extent of which is
determined by the arguments:  
   (THSUCCEED THTAG <tag>) = (THGO <tag>) - see THPROG.  
   (THSUCCEED THPROG <e>) = (THRETURN <e>) - see THPROG.  
   (THSUCCEED <place>) = (THSUCCEED <place>  T) 


   (THSUCCEED THEOREM <e>) causes theorem to succeed with value of <e>.  
   (THSUCCEED THEOREM)  causes the theorem to succeed with value THNOVAL.
   (THSUCCEED) causes a simple success to propagate.  
.SP
38) (THUNIQUE <exp1> <exp2> ...) 
	THUNIQUE is a state filter.  It causes failure if the list
consisting of the values of its arguments has been computed by
any previously executed THUNIQUE.  For example, a consequent theorem
named THM1 can be prevented from getting into a loop by
calling itself recursively (via any intermediate theorems) with 
arguments identical to those supplied to the theorem at the higher
level activation by making 
	(THUNIQUE 'THM1 $?X1 $?X2 ... ) 
.BR
the first statement of the theorem's body, where $?X1, $?X2, ... are
the planner variables occurring in the theorem's pattern.
.SP
39)  (THV  <variable name>)  (THNV <variable name>) 
   These LISP functions get the PLANNER value of the variable whose name
is given.  The atoms THV and THNV also serve as markers of the special
variable flags to the matcher.  (THV FOO) is $?FOO and (THNV FOO) is
$_FOO by using the macro-character feature of LISP 1.6.  
.SP
40)  (THVAL <expression> <alist>) 
   THVAL is the Micro-Planner evaluator  just as EVAL is the LISP


evaluator.  As in LISP, the first argument is evaluated (THVALuated) with
free variables in it given the values associated with them on the given
alist.  Micro-Planner's alist, called THALIST, is a list of pairs (CAR- 
CADR not CAR-CDR) of variable names and values.  If you want to stop a
Micro-Planner evaluation at the next interruptable place hit ctrl-A.
Planner will then type out ^A-THVAL and go into a THERT listen
loop (see THERT).  The
next expression to be executed is in the variable THE.  To proceed, type
$p<space>.  Warning:  an explicit call to THVAL may not be reentered
for backup upon failure after that call returns.   
.SP
41)  (THVSETQ <var1> <e1> ... <varn> <en>) 
   Sets the variables to the values of eis as in THSETQ.  Not undone on
failure backup.  See warning about THVAL. 
.SP
42)  Abbreviations
.sp
	$?x  =  (THV x)
	$_x  =  (THNV x)
	$Ex =  (THEV x)
	$R   =  THRESTRICT
	$G   =  THGOAL
	$A   =  THASSERT
	$Nx =  (THANUM x)
	$T   =  (THTBF THTRUE)
	$& ... & is ignored
  

.sp
43)  The Matcher 
   The Matcher in Micro-Planner is elementary and contains a minimum of
bells and whistles but is (hopefully) sufficiently powerful for most
problems.  Micro-Planner's matcher only matches lists one level deep and only has
two distinct kinds of variable occurrences.  The matcher's actions can be
summarized in the 6-by-6 chart on the next page, which shows how any two
pattern elements interact.  One nice hook in the matcher is that a
pattern element (or the entire pattern) 
may be of the form $E<expression> or (THEV <expression>)
(those macro-characters are at it again!) , which means that the element
(or pattern)
is to be replaced with the result of THVALuating the expression with an
appropriate THALIST.  For example, to stack up all red objects:  
.sp 1
   (THGOAL (#STACKUP $E(THFIND ALL $?X (X) (THGOAL (#COLOR $?X #RED))
))).   
.sp 1
	See THRESTRICT for more powerful matching methods
.PA
MATCHER CHARACTERISTICS 
.PA


IV.  A Compendium of Micro-Planner Error Comments 
   The Micro-Planner error comments are meant to be self-explanatory.  If
you come across one which is not, it is probably meant for me, not you,
and it would help in removing residual bugs for you to save the situation
and show it to me.  All Micro-Planner error comments are typed out by a
break function called THERT which leaves you in a LISP listen loop at a
point as close as possible to the occurrence of the error, so that the
state of the system may be interrogated.    Usually the error is fatal,
but if you wish to proceed, type $P<space> (See THERT). 
Usually something is typed out before the error comment;  that is
the object the comment is complaining about.  Micro-Planner error
comments almost always end with - <funny word>; the <funny word> is the
name of the system function which got mad.  In many
cases, Micro - Planner will catch the error before
it has done anything too drastic.  In such cases the user
will be able to patch things up on the fly, and continue
as if nothing happened.  Whether or not
this can be done depends on the kind of error. 
	The authorized list follows:
.SP
LISPERROR - THVAL 
   LISP became unhappy when trying to evaluate the expression typed out.
If proceeded, the value of THERT will be assumed
to be the value of the expression which caused
the error. 
.SP
BAD SUCCEED - THVAL, or BAD FAIL - THVAL 
   You were screwed by a Planner bug.  Please save situation and contact
me.  
.SP
UNCLEAR RECOMMENDATION - THTRY 
   The expression typed out before the error comment was a recommendation
to THGOAL which was not either a THTBF, THDBF, THNUM, or a THUSE, or was a
THANUM or THNODB which did not come first in the list.  
If proceeded, the value of THERT will be
assumed to be the correct recommendation.  Atomic recommendations
are ignored.  Since proceeding with $P is
equivalent to proceeding with the value T , $P in
effect says to ignore the recommendation entirely
.SP
BAD THEOREM - THTRY1 
   The expression printed was passed to THGOAL as a theorem.  It either
did not have a THEOREM property or was not a consequent theorem.  
If proceeded with a value, the value will be
assumed to be the correct theorem name.  If $P is
used, this theorem will be ignored and the next
item on the recommendation list will be tried. 
.SP
BAD CALL - THFINALIZE 
   You called THFINALIZE without giving a place to finalize to.  
If proceeded, the value of the THERT is taken
as a specification of the place.  If $P is used, the finalize is ignored. 
.SP
OVERPOP - THFINALIZE 
   THFINALIZE overpopped THTREE trying to find the lousy place to stop.  
This is a fatal error.  No recovery is possible. 
.SP
OVERPOP - THSUCCEED 
   THSUCCEED overpopped THTREE trying to find the place to stop
succeeding.   Remember that THGO and THRETURN use THSUCCEED.  
Fatal error. 
.SP
NOT FOUND - THFAIL 
   THFAIL could not find the place to stop failing.  
If proceeded the value of THERT is taken as a specification of
the place.  If it is T or NIL then it is just
returned as the value of THFAIL.
.SP
IMPURE ASSERTION OR ERASURE - THASS1 
   The datum you tried to assert or erase had a variable which was
unassigned.   
The offending assertion is in the variable THX.  You
may edit it to be pure and then proceed the program.
.SP
BAD THEOREM - THTAE 
   You tried to THUSE an antecedent or erasing theorem which was of the
wrong type or did not have a theorem property.  
If you proceed the value of THERT is assumed to
be the correct theorem name.  If you had just forgotten
to define the theorem, feel free to define it before
you proceed, and return the same name. 
.SP
UNCLEAR RECOMMENDATION - THTAE 


   You gave a THASSERT or THERASE recommendation which was not a THTBF or
a THUSE.  
As in THTRY, the value of THERT
is assumed to be the corrected recommendation.  Atomic ones
are again ignored. 
.SP
ODD NUMBER OF GOODIES - THSETQ, or ODD NUMBER OF GOODIES - THVSETQ 
   THSETQ or THVSETQ does not know what to do with the last goodie.  
Proceeding will cause the odd goodie to
be ignored.  (Naturally the error will be ignored also.)
.SP
THUNBOUND - THV1 
   You tried to access the value of the unbound variable printed.  
If proceeded, the value of THERT will be assumed
to be the value cell of the variable which was not bound. 
.SP
THUNASSIGNED - THV1 
   You tried to use the value of the unassigned variable printed.  
The value of THERT is taken as the value of the variable
in the current expression.  Note that if you want the
variable to have this value later, you had better THVSETQ
it. 
.SP
THUNBOUND - THGAL 
   You tried to access the unbound variable printed.  
Proceed as in THUNBOUND - THV1.
.PA
V.  Hints and Kinks
.SP
1)	All atoms whose pnames begin with TH are property of Micro-Planner
and should not be used in programs designed to interact with it.
.SP
2)	When Micro-Planner is loaded (by :PLNR in DDT) it is listening
in a READ-THVAL-PRINT loop at the top level.  Typing
$P<space> will cause this loop to be exited to a LISP READ-EVAL-PRINT
loop.  Any error condition which propagates to the top level (eg. cntrl-G) will
restart the READ-THVAL-PRINT listen loop.
.SP
3)	The system version of Micro-Planner has a LAP in it.  It is desirable
to REMLAP at the earliest possible time as the LAP  takes up lots of
space.
.SP
4)	The EXPR version of Micro-Planner is in DSK:PLNR; PLNR > 
and the LAP version is stored in DSK:PLNR;PLNR LAP.
.SP
5)	Because most Micro-Planner primitives operate by modifying THTREE
and then returning, it is fairly unilluminating
to try to trace them with a LISP tracer (which is good for the LISP  
recursive control structure). For that reason I have taken pains to provide
a tracer which is more relevant to the planner control structure.  It is
available as EXPR code in DSK:PLNR;THTRAC >.
With it one can conditionally trace  and break on theorems, assertions,
erasures, and goals.  To use the tracer one must first read it in and then 
incant (THTRACE <obj1> . . . <objn>), where  each object is an
item to be traced or broken at.  The possible entries are either:
.BR
<atom>   abbreviation for (<atom> t nil)
.BR
(<atom> <trace condition>)   abbreviation for (<atom> <trace condition> nil)
or
.BR
(<atom> <trace condition> <break condition>)
.BR
The CAR of the item may either be the name of a theorem or one of the following
atoms which have special meanings:
.BR
THEOREM   all theorems
.BR
THGOAL   all goals 
.BR
THASSERT   all assertions
.BR
THERASE   all erasures
.BR
THBKPT   all breakpoints
.BR
The conditions are THVALed with the THALIST which is current at the 
time of call and thus may be arbitrary PLANNER programs which test
the state of variables and the data base.  Tracing of selected items, or
of all items may be terminated using THUNTRACE.
.SP

6)	A Micro-Planner program may at any point call a LISP program, but
a LISP program may not call a Micro-Planner  primitive because the PLANNER
control structure is not really recursive.  If a LISP routine wishes to call a 
PLANNER program it must explicitly THVAL it with an appropriate
THALIST.
Be especially careful not to screw around with the LISP values of
Micro-Planner primitives unless you understand what you are doing.  The
possibilities for lossage are infinite.
.END

;SIZE 11
;VSP 6
;TOPMAR 0
;BOTMAR 0
;LFTMAR 0
;SKIP 1
;KSET ,,,,,
AI:RG;NNTJ6 10.5

Å Micro-Planner Reference Manual
Å hby
Å @Gerald Jay Sussman, Terry Winograd, and Eugene Charniak

Å  I.   Introduction

Å  1)  Micro-Planner is an implementation of a subset of Carl Hewitt's
Å  language, PLANNER, by Gerald Jay Sussman, Terry Winograd, and Eugene
Å  Charniak on the AI group computer in LISP.  Micro-Planner is now a publicly
Å  accessible systems program in the AI group system ITS.  The current version
Å  of Micro-Planner, embedded in an allocated LISP, may be obtained by
Å  incanting ":PLNR" or "PLNR<control-K>" to DDT.  Micro-Planner is also
Å  available as EXPR code or LAP code.  All questions, suggestions, or
Å  comments about Micro-Planner should be directed to Gerald Jay Sussman
Å  (login name GJS) who will maintain the program.

Å  2)  Philosophical Overview
Å  The "level" of  a programming language is a term which is in fairly
Å  common usage in the computer culture.  We all agree, for example, that
Å  FORTRAN, LISP, and PL1 are higher level languages than, say assembly
Å  language, regardless of our opinions of their relative merits for
Å  expressing our individual styles of programming.  After some introspection,
Å  I decided that what is meant by the level  of a language is the amount of
Å  knowledge of programming style implicit in the language processor and thus
Å  the quantity of detail which the user does not explicitly have to specify
Å  because he may assume that the processor will fill in for him.  When we
Å  express the value judgment that LISP or PL1, for example, is a lousy
Å  language, what we mean is that the stylistic assumptions made by the
Å  designers of the language are incompatible with our own styles and thus
Å  overly restrict us.  There are some of us (may ITS preserve their file
Å  directories!) with whom any restrictions are incompatible and who thus
Å  always write in assembly language.  There are others, such as I, who find
Å  such restrictions an aid in the organization of large programs.  Thus, to
Å  me, LISP is useful in that it provides a large library of subroutines with
Å  uniform calling sequences, a convenient evaluator for defining recursively
Å  reentrant procedures from those primitives and a bookkeeper for the
Å  maintenance of a list structured data base.  Indeed for these conveniences
Å  I pay heavily in space and time efficiency, as well as in some feeling of
Å  constrained style.
Å  PLANNER is the first of perhaps a whole new level of languages
Å  which will basically be oriented toward the accomplishment of tasks (or
Å  goals) which may in fact be broken down into subtasks (subgoals).  By
Å  contrast, in previous languages (as LISP) problem solutions are expressed
Å  in terms of procedures (functions).  The distinction is not immediately
Å  apparent but should become more clear if we note that in a PLANNER program,
Å  if a goal is activated then it may be satisfied by any number of objects in
Å  the data base or by any number of theorems (the analogue of procedure).  A
Å  backup mechanism is provided so that one of the possibilities is tried, and
Å  then if, as a consequence a failure occurs, then another is tried, etc.

Å pPAGE 2

Å  Furthermore, the data and theorems need not be referenced explicitly, but
Å  rather by saying, in essence, "the datum (or procedure)" which fits the
Å  following pattern (or accomplishes the desired result).  In order for such
Å  data and theorems to be implicitly referenced efficiently the system has
Å  the responsibility of constructing and accessing a cross-referenced data
Å  base of "assertions" (data) and theorems (programs).


Å pPAGE 3

Å  II.  Programming in Micro-Planner

Å  The easiest way to understand Micro-Planner is to watch how it
Å  works, so in this section we will present a few simple examples and explain
Å  the use of some of its most elementary features.
Å  
Å pFirst we will take the most venerable of traditional deductions:

Å PTuring is a human
Å PAll humans are fallible
Å 0so
Å PTuring is fallible.
Å @

Å  
Å pIt is easy enough to see how this could be expressed in the usual
Å  logical notation and handled by a uniform proof procedure.  Instead, let us
Å  express it in one possible way to Micro-Planner  by saying:

Å 0
Å P(THASSERT (HUMAN TURING))
Å P(THCONSE (X) (FALLIBLE $?X)
Å  (THGOAL (HUMAN $?X)))
Å 0

Å  
Å  
Å pThe proof would be generated by asking Micro-Planner to evaluate the
Å  expression:

Å p(THGOAL (FALLIBLE TURING) $T)

Å pWe immediately see several points.  First, there are two different
Å  ways of storing information.  Simple assertions  are stored in a data base
Å  of assertions, while more complex sentences containing quantifiers or
Å  logical connectives are expressed in the form of theorems.
Å pSecond, one of the most important points about Micro-Planner is that
Å  it is an evaluator for statements written in a programming language.  It
Å  accepts input in the form of expressions written in the Micro-Planner
Å  language, and evaluates them, producing a value and side effects.  THASSERT
Å  is a function which, when evaluated, stores its argument in the data base
Å  of assertions or the data base of theorems (which are cross-referenced in
Å  various ways to give the system efficient look-up capabilities).  In this
Å  example the second line defines a theorem of the THCONSE type  (THCONSE
Å  means consequent; we will see other types later).  This states that if we
Å  ever want to establish a goal of the form (FALLIBLE $?X), we can do this by
Å  accomplishing the goal (HUMAN $?X), where X is a variable.  Note that
Å  symbols like FALLIBLE and HUMAN have no "meaning" in Micro Planner.  (All
Å  Micro Planner symbols start with TH .)  Nor is there any significance to
Å  the order in which elements appear in the pattern.  We could have said

Å pPAGE 4

Å  (TURING IS-AN OSTRICH) for all Micro Planner cares.  The strange prefix
Å  characters are part of Micro-Planner's pattern matching capabilities.  If
Å  we ask Micro-Planner to prove a goal of the form (A X), there is no obvious
Å  way of knowing whether A and X are constants (like TURING and HUMAN in the
Å  example) or variables.  LISP solves this problem by using the function
Å  QUOTE to indicate constants.  In pattern matching this is inconvenient and
Å  makes most patterns much bulkier and more difficult to read.  Instead,
Å  Micro-Planner uses the opposite convention -- a constant is represented by
Å  the atom itself, while a variable must be indicated by adding an
Å  appropriate prefix.  This prefix differs according to the exact use of the
Å  variable in the pattern, but for the time being let us just accept $?
Å  (this is a dollar-sign -- not an alt-mode) as a prefix indicating a
Å  variable.  The definition of the theorem indicates that it has one
Å  variable, X by the (X) following THCONSE.
Å 0
Å pThe third statement  illustrates the function THGOAL, which calls the
Å  Micro-Planner interpreter to try to prove an assertion.  This can function
Å  in several ways.  If we had asked Micro-Planner to evaluate (THGOAL (HUMAN
Å  TURING)) it would have found the requested assertion immediately in the
Å  data base and succeeded (returning as its value some indicator that it had
Å  succeeded).  However, (FALLIBLE TURING) has not been asserted, so we must
Å  resort to theorems to prove it.  Later we will see that a THGOAL statement
Å  can give Micro-Planner various kinds of advice on which theorems are
Å  applicable to the goal and should be tried.  For the moment, $T is advice
Å  that causes the evaluator to try all theorems whose consequent is of a form
Å  which matches the goal.  (i.e. a theorem with a consequent ($?Z TURING)
Å  would be tried, but one of the form (HAPPY $?Z) or (FALLIBLE $?Y $?Z) would
Å  not.  If there is no advice only the data base will be tried.  Assertions
Å  can not have an arbitrary list structure for their format but they are not
Å  limited to two-member lists or three-member lists as in these examples.)
Å  The theorem we have just defined would be found, and in trying it, the
Å  match of the consequence to the goal would cause the variable $?X to be
Å  assigned to the constant TURING.  Therefore, the theorem sets up a new goal
Å  (HUMAN TURING) and this succeeds immediately since it is in the data base.
Å  In general, the success of a theorem will depend on evaluating a Micro-
Å  Planner program of arbitrary complexity.  In this case it contains only a
Å  single THGOAL statement, so its success causes the entire theorem to
Å  succeed, and the goal (FALLIBLE TURING) is proved.
Å 0
Å  Consider the question "Is anything fallible?", or in logic (EXISTS
Å  (Y)(FALLIBLE Y)).  This requires a variable and it could be expressed in
Å  Micro-Planner as:

Å p(THPROG (Y) (THGOAL (FALLIBLE $?Y) $T) (THRETURN $?Y))

Å pNotice that THPROG (Micro-Planner's equivalent of a LISP PROG,
Å  complete with GO statements, tags, RETURN, etc.) acts as an existential
Å  quantifier.  It provides a binding-place for the variable Y, but does not
Å  initialize it -- it leaves it in a state particularly marked as unassigned.
Å  To answer the question, we ask Micro-Planner to evaluate the entire THPROG

Å pPAGE 5

Å  expression above.  To do this it starts by evaluating the THGOAL
Å  expression.  This searches the data base for an assertion of the form
Å  (FALLIBLE $?Y) and fails.  It then looks for a theorem with a consequent of
Å  that form, and finds the theorem we defined above. Now when the theorem is
Å  called, the variable X in the theorem is identified with the variable Y in
Å  the goal, but since Y has no value yet, X does not receive a value.  The
Å  theorem then sets up the goal (HUMAN $?X) with X as a variable.  The data-
Å  base searching mechanism takes this as a command to look for any assertion
Å  which matches that pattern (i.e. an instantiation), and finds the assertion
Å  (HUMAN TURING).  This causes X (and therefore Y) to be assigned to the
Å  constant TURING, and the theorem succeeds, completing the proof and
Å  returning the value TURING.
Å pThere seems to be something missing.  So far,the data base has
Å  contained only the relevant objects, and therefore Micro-Planner has found
Å  the right assertions immediately.  Consider the problem we would get if we
Å  added new information by evaluating the statements:

Å 0
Å P(THASSERT (HUMAN SOCRATES))
Å P(THASSERT (GREEK SOCRATES))
Å P(THASSERT (HUMAN NEWTON))
Å @
Å 0

Å  
Å pOur data base now contains the assertions:

Å @(HUMAN TURING)
Å @(HUMAN SOCRATES)
Å @(GREEK SOCRATES)
Å @(HUMAN NEWTON)

Å Pand the theorem:

Å @(THCONSE (X) (FALLIBLE $?X)
Å (THGOAL (HUMAN $?X)))

Å @
Å pWhat if we now ask, "Is there a fallible Greek?" In Micro-Planner we
Å  would do this by evaluating the expression:

Å P(THPROG (X)
Å  (THGOAL (FALLIBLE $?X)$T)
Å  (THGOAL (GREEK $?X))
Å  (THRETURN $?X))

Å  THPROG acts like an AND, insisting that all of its terms are satisfied
Å  before the THPROG is happy.  Notice what might happen. The first THGOAL may
Å  be satisfied by the exact same deduction as before, since we have not
Å  removed information.  Since the data-base searcher will run into NEWTON

Å pPAGE 6

Å  before it finds SOCRATES, the goal (HUMAN $?X) will succeed, assigning $?X
Å  to NEWTON.  After (FALLIBLE $?X) succeds,  the THPROG will then establish
Å  the new goal (GREEK NEWTON), which is doomed to fail since it has not been
Å  asserted, and there are no applicable theorems.  If we think in LISP terms,
Å  this is a serious problem, since the evaluation of the first THGOAL has
Å  been completed before the second one is called, and the "push-down list"
Å  now contains only the THPROG.  If we try to go back to the beginning and
Å  start over, it will again find NEWTON and so on, ad infinitum.
Å pOne of the most important features of the Micro-Planner language is
Å  that backup in case of failure is always possible, and moreover this backup
Å  can go to the last place where a decision of any sort was made.  Here, the
Å  decision was to pick a particular assertion from the data base to match a
Å  goal.  Other decisions might be the choice of a theorem to satisfy a goal,
Å  or a decision of other types found in more complex Micro-Planner functions.
Å  Micro-Planner keeps enough information to change any decision and send
Å  evaluation back down a new path.
Å pIn our example the decision was made inside the theorem for FALLIBLE,
Å  when the goal (HUMAN $?X) was matched to the assertion (HUMAN NEWTON).
Å  Micro-Planner will retrace its steps, try to find a different assertion
Å  which matches the goal, find (HUMAN SOCRATES), and continue with the proof.
Å  The theorem will succeed with the value (FALLIBLE SOCRATES), and the THPROG
Å  will proceed to the next expression, (THGOAL (GREEK $?X)).  Since X has
Å  been assigned to SOCRATES, this will set up the goal (GREEK SOCRATES) which
Å  will succeed immediately by finding the corresponding assertion in the data
Å  base.  The program will then return the value SOCRATES.  If there were no
Å  explicit THRETURN statement, and the THPROG was allowed to fall off its
Å  end, it would return the default value THNOVAL.  The whole course of the
Å  deduction process depends on the failure mechanism for backing up and
Å  trying things over (this is actually the process of trying different
Å  branches down the subgoal tree.) All of the functions like THCOND, THAND,
Å  THOR, etc. are controlled by success vs. failure.  Thus it is the Micro-
Å  Planner executive which establishes and manipulates subgoals in looking for
Å  a proof.
Å  
Å pAlthough Micro-Planner is written as a programming language, it
Å  differs in several critical ways from anything which is normally considered
Å  a programming language.  First, it is goal-directed.  Theorems can be
Å  thought of as subroutines, but they can be called by specifying the goal
Å  which is to be satisfied.  This is like having the ability to say "Call a
Å  subroutine which will achieve the desired result at this point."  Second,
Å  the evaluator has the mechanism of success and failure to handle the
Å  exploration of the subgoal tree.  Other evaluators, such as LISP, with a
Å  basic recursive evaluator have no way to do this.  Third, Micro-Planner
Å  contains a bookkeeping system for matching patterns and manipulating a data
Å  base, and for handling that data base efficiently.
Å  
Å pHow is Micro-Planner different from a theorem prover?  What is gained
Å  by writing theorems in the form of programs, and giving them power to call
Å  other programs which manipulate data?  The key is in the form of the data
Å  the theorem-prover can accept.  Most systems take dÇp_eÇp_cÇp_lÇp_aÇp_rÇp_aÇp_tÇp_iÇp_vÇp_eÇp_ information,

Å pPAGE 7

Å  as in predicate calculus.  This is in the form of expressions which
Å  represent "facts" about the world.  These are manipulated by the theorem-
Å  prover according to some fixed uniform process set by the system.  Micro-
Å  Planner can make use of iÇp_mÇp_pÇp_eÇp_rÇp_aÇp_tÇp_iÇp_vÇp_eÇp_ information, telling it how to go about
Å  proving a subgoal, or to make use of an assertion.  This produces what is
Å  called hÇp_iÇp_eÇp_rÇp_aÇp_rÇp_cÇp_hÇp_iÇp_cÇp_aÇp_lÇp_ cÇp_oÇp_nÇp_tÇp_rÇp_oÇp_lÇp_ sÇp_tÇp_rÇp_uÇp_cÇp_tÇp_uÇp_rÇp_eÇp_.  That is, any theorem can indicate
Å  what the theorem prover is supposed to do as it continues the proof.  It
Å  has the full power of a general programming language to evaluate functions
Å  which can depend on both the data base and the subgoal tree, and to use its
Å  results to control the further proof by making assertions, deciding what
Å  theorems are to be used, and specifying a sequence of steps to be followed.
Å  What does this mean in practical terms?  In what way does it make a
Å  "better" theorem prover?  We will give several examples of areas where the
Å  approach is important.
Å  
Å pFirst, consider the basic problem of deciding what subgoals to try  in
Å  attempting to satisfy a goal.  Very often, knowledge of the subject matter
Å  will tell us that certain methods are very likely to succeed, others may be
Å  useful if certain other conditions are present, while others may be
Å  possibly valuable, but not likely.  We would like to have the ability to
Å  use heuristic programs to determine these facts and direct the theorem
Å  prover accordingly.  It should be able to direct the search for goals and
Å  solutions in the best way possible, and able to bring as much intelligence
Å  as possible to bear on the decision.  In Micro-Planner this is done by
Å  adding to our THGOAL statement a rÇp_eÇp_cÇp_oÇp_mÇp_mÇp_eÇp_nÇp_dÇp_aÇp_tÇp_iÇp_oÇp_nÇp_ lÇp_iÇp_sÇp_tÇp_ which can specify that
Å  ONLY certain theorems are to be tried, or that certain ones are to be tried
Å  FIRST in a specified order.  Since theorems are programs, subroutines of
Å  any type can be called to help make this decision before establishing a new
Å  THGOAL.  A theorem can be given a name so that it can be explicitly
Å  referred to.  In our example, however, we did not do so.  If we had wanted
Å  to name it, say, FALLIBLE-PROVER, we would have written

Å  
Å  (THCONSE FALLIBLE-PROVER (X)  ... )

Å  
Å pAn important problem is that of maintaining a data base with a
Å  reasonable amount of material.  Consider the first example above.  The
Å  statement that all humans are fallible, while unambiguous in a declarative
Å  sense is actually ambiguous in its imperative sense (i.e. the way it is to
Å  be used by the theorem prover).  The first way is to simply use it whenever
Å  we are faced with the need to prove (FALLIBLE $?X).  Another way might be
Å  to watch for a statement of the form (HUMAN $?X) to be asserted, and to
Å  immediately assert (FALLIBLE $?X) as well. There is no abstract logical
Å  difference, but the impact on the data base is tremendous.  The more
Å  conclusions we draw when information is asserted, the easier proofs will
Å  be, since they will not have to make the additional steps to deduce these
Å  consequences over and over again.  However since we don't have infinite
Å  speed and size, it is clearly folly to think of deducing and asserting
Å  everything possible (or even everything interesting) about the data when it

Å pPAGE 8

Å  is entered.  If we were working with totally abstract, meaningless theorems
Å  and axioms (an assumption which would not be incompatible with many
Å  theorem-proving schemes), this would be an insolvable dilemma.  But Micro-
Å  Planner is designed to work in the real world, where our knowledge is much
Å  more structured than a set of axioms and rules of inference.  We may very
Å  well, when we assert (LIKES $?X POETRY)  want to deduce and assert (HUMAN
Å  $?X), since in deducing things about an object, it will very often be
Å  relevant whether that object is human, and we shouldn't need to deduce it
Å  each time.  On the other hand, it would be silly to assert (HAS-AS-PART $?X
Å  SPLEEN), since there is a horde of facts equally important and equally
Å  limited in use.  Part of the knowledge which Micro-Planner should have of a
Å  subject, then, is what facts are important, and when to draw consequences
Å  of an assertion.  This is done by having theorems of an antecedent type:

Å 0
Å  (THANTE (X Y) (LIKES $?X $?Y)
Å  (THASSERT (HUMAN $?X)))
Å 0

Å  
Å  
Å pThis says that when we assert that X likes something, we should also
Å  assert (HUMAN $?X). Of course, such theorems do not have to be so simple.
Å  A fully general Micro-Planner program can be activated by an THANTE
Å  theorem, doing an arbitrary (that is, the programmer has free choice)
Å  amount of deduction, assertion, etc.  Knowledge of what we are doing in a
Å  particular problem may indicate that it is sometimes a good idea to do this
Å  kind of deduction, and other times not.  As with the consequent theorems,
Å  Micro-Planner has the full capacity when something is asserted, to evaluate
Å  the current state of the data and proof, and specifically decide which
Å  antecedent theorems should be called.
Å pMicro-Planner therefore allows deductions to use all sorts of
Å  knowledge about the subject matter which go far beyond the set of axioms
Å  and basic deductive rules. Micro-Planner itself is subject-independent, but
Å  its power is that the deduction processs never needs to operate on such a
Å  level of ignorance.  The programmer can put in as much heuristic knowledge
Å  as he wants to about the subject, just as a good teacher would help a class
Å  to understand a mathematical theory, rather than just telling them the
Å  axioms and then giving theorems to prove.
Å  
Å  
Å pAnother advantage in representing knowledge in an imperative form is
Å  the use of a theorem prover in dealing with processes involving a sequence
Å  of events.  Consider the case of a robot manipulating blocks on a table.
Å  It might have data of the form, "block1 is on block2," "block2 is behind
Å  block3", and "if x is on y and you put it on z, then x is on z, and is no
Å  longer on y unless y is the same as z".  Many examples in papers on theorem
Å  provers are of this form (for example the classic "monkey and bananas"
Å  problem).  The problem is that a declarative theorem prover cannot accept a
Å  statement like (ON B1 B2) at face value.  It clearly is not an axiom of the

Å pPAGE 9

Å  system, since its validity will change as the process goes on.  It must be
Å  put in a form (ON B1 B2 S0) where S0 is a symbol for an initial state of
Å  the world.  The third statement might be expressed as:
Å  

Å  (FORALL (X Y Z S)(AND (ON X Y (PUT X Y S))
Å  (OR(EQUAL Y Z)
Å 0(NOT(ON X Z (PUT X Y S))))))
Å  

Å @
Å pIn this representation, PUT is a function whose value is the state
Å  which results from putting X on Y when the previous state was S.  We run
Å  into a problem when we try to ask (ON Z W (PUT X Y S))  i.e. is block Z on
Å  block W after we put X on Y? A human knows that if we haven't touched Z or
Å  W we could just ask (ON Z W S) but in general it may take a complex
Å  deduction to decide whether we have actually moved them, and even if we
Å  haven't, it will take a whole chain of deductions (tracing back through the
Å  time sequence) to prove they haven't been moved.  In Micro-Planner, where
Å  we specify a process directly, this whole type of problem can be handled in
Å  an intuitively more satisfactory way by using the primitive function
Å  THERASE.
Å pEvaluating (THERASE (ON $?X $?Y)) removes the assertion (ON $?X $?Y)
Å  from the data base.  If we think of theorem provers as working with a set
Å  of axioms, it seems strange to have a function whose purpose is to erase
Å  axioms.  If instead we think of the data base as the "state of the world"
Å  and the operation of the prover as manipulating that state, it allows us to
Å  make great simplifications. Now we can simply assert (ON B1 B2) without any
Å  explicit mention of states.  We can express the necessary theorem as:

Å  
Å @(THCONSE (X Y Z)
Å P(PUT $?X $?Y)
Å P(THGOAL (ON $?X $?Z))
Å P(THERASE (ON $?X $?Z))
Å P(THASSERT (ON $?X $?Y)))
Å @
Å 0

Å  This says that whenever we want to satisfy a goal of the form (PUT
Å  $?X $?Y), we should first find out what thing Z the thing X is sitting on,
Å  erase the fact that it is sitting on Z, and assert that it is sitting on Y.
Å  We could also do a number of other things, such as proving that it is
Å  indeed possible to put X on Y, or adding a list of specific instructions to
Å  a movement plan for an arm to actually execute the goal.  In a more complex
Å  case, other interactions might be involved.  For example, if we are keeping
Å  assertions of the form (ABOVE $?X $?Y) we would need to delete those
Å  assertions which became false when we erased (ON $?X $?Z) and add those
Å  which became true when we added (ON $?X $?Y).  Antecedent theorems could be
Å  called by the assertion (ON $?X $?Y) to take care of that part, and a

Å `PAGE 10

Å  similar group called erasing theorems can be called in an exactly analogous
Å  way when an assertion is erased, to derive consequences of the erasure.
Å  Again we emphasize, which theorems will be called can be made dependent on
Å  the way the data base is structured, which in turn can reflect knowledge of
Å  the subject matter.  In this example, we would have to decide whether it
Å  was worth adding all of the above relations to the data base, with the
Å  resultant need to check them whenever something is moved, or instead to
Å  omit them and take time to deduce them from the ON relation each time they
Å  are needed.
Å pThus in Micro-Planner, the changing state of the world can be mirrored
Å  in the changing state of the data base, avoiding any need to make explicit
Å  mention of states, with the requisite overhead of deductions.  This is
Å  possible since the information is given in an imperative form, specifying
Å  theorems as a series of specific steps to be executed.
Å pIf we look back to the distinction between assertions and theorems
Å  made on the first page, it would seem that we have established that the
Å  base of assertions is the "current state of the world", while the base of
Å  theorems is our permanent knowledge of how to deduce things from that
Å  state.  This is not exactly true, and one of the most exciting
Å  possibilities in Micro-Planner is the capability for the program itself to
Å  create and modify the Micro-Planner functions which make up the theorem
Å  base.  Rather than simply making assertions, a particular Micro-Planner
Å  function might be written to put together a new theorem or make changes to
Å  an existing theorem, in a way dependent on the data and current knowledge.
Å  It seems likely that meaningful "learning" involves this type of behavior
Å  rather than simply modifying parameters or adding more individual facts
Å  (assertions) to a declarative data base.
Å  
Å  
Å 0


Å `PAGE 11

Å  
Å  III.  The Micro-Planner Primitives

Å  This section will basically be a list of the Micro-Planner
Å  primitives with a detailed description of each.  Meta-Linguistic variables
Å  will be enclosed in angle brackets (<>).
Å  The heart of Micro-Planner is a structure known as THTREE; it is to
Å  the hierarchical control structure of PLANNER what a push-down list is to a
Å  recursive control structure such as is found in LISP.  In LISP the push-
Å  down list remembers the return addresses of recursive function calls; in
Å  Micro-Planner THTREE keeps track of the decisions (or hypotheses) made so
Å  far in the problem-solving process which are currently considered relevant
Å  to the solution.  In case a failure occurs PLANNER can back up THTREE,
Å  undoing the decisions which caused the failure until a promising approach
Å  is found.  If none is found the program returns a failure.  THTREE is a
Å  tree structure, each node of which contains information about how to
Å  proceed in case either success or failure propagates to that node.  Failure
Å  is propagated from a node if and only if a failure propagates to it and no
Å  further possibilities exist at that node.  A node of THTREE may be thought
Å  of as a goal, with branches originating at this node associated with
Å  tentatively useful hypotheses for establishing the goal.
Å PClosely associated with THTREE is THALIST, the list of variable
Å  bindings.  Certain primitives bind variables by declaration.  In their
Å  initial bound state variables are called unassigned and are assigned to
Å  "THUNASSIGNED."  THALIST shares the tree structure of THTREE.
Å  Because of the non-recursive implementation of the Micro-Planner
Å  interpreter the PLANNER value of an expression is not the same as its LISP
Å  value.  In most cases this is unimportant because PLANNER expressions are
Å  usually executed for effect rather than for value.  The PLANNER value of an
Å  expression is however available as the LISP value of the LISP free variable
Å  THVALUE immediately after the expression is executed.  Although this is not
Å  a very pretty convention it introduces some very great simplifications in
Å  the implementation.

Å  
Å  1)  .PLNR. (INIT)
Å  One can have a PLANNER INIT file in the same way one has a teco
Å  init file.  The file name should be as above.

Å  
Å  
Å  2)  (THAMONG <variable name> <expression>)
Å PUpon entry the variable named (by an atom) must be bound.  If it is
Å  unassigned then it will be assigned to the first member of the list of
Å  choices to which <expression> THVALuates.  If the variable already has a
Å  value (is assigned), THAMONG fails unless the assigned value is already
Å  among the choices.  Each time a failure backs up to the THAMONG the
Å  variable will be assigned to the next element of the choice list.  If it
Å  runs out of choices it fails, otherwise it succeeds.


Å `PAGE 12

Å  3)  (THAND <e1> ... <en>)
Å PTHAND fails unless each of its subexpressions succeeds in sequence,
Å  allowing for backup.  It is just like THPROG except that there are no
Å  variable declarations or tags allowed.

Å  4)  (THANTE <thm-name> <list-of-variables> <pattern> <body>)
Å  THANTE works in a similar fashion to THCONSE to define and
Å  (optionally) assert antecedent theorems.

Å  5)  (THAPPLY <theorem> <datum>)  calls the specified theorem causing it to
Å  match its pattern to the specified datum.  If it matches, the theorem is
Å  executed with <datum> as its "argument."  The THVALUE of a THAPPLY is the
Å  value of the theorem applied.
Å 0

Å  6)  (THASSERT <skeleton> <rec1> ... <recn>)
Å PTHASSERT adds the assertion (formed by substituting assignments for
Å  variables (or by THVALing $E's as described in the matcher section) in the
Å  skeleton) to the data-base except if the skeleton is an atom, in which case
Å  it adds the atom as a theorem to the theorem base.
Å PTHASSERT only fails if it tries to assert an already existing assertion.
Å  If the first recommendation to a THASSERT is a (THPROP <e>) then the LISP
Å  value of <e> is used as the property list of the assertion being asserted.
Å  A more complex recommendation is THPSEUDO, which has its own listing.
Å  THASSERT also may recommend antecedent theorems with THTBF or THUSE as in
Å  THGOAL, though the success or failure of those theorems is irrelevant to
Å  success or failure of the assertion.  The PLANNER value of a THASSERT is
Å  the object asserted.

Å  7)  (THASVAL <variable>)
Å PTHASVAL is a predicate which assumes that the indicated variable is
Å  bound.  It succeeds if and only if the variable is assigned a value.

Å  8) (THBKPT <comment>)
Å  THBKPT has no effect unless traced. If it is, its comment is
Å  
Å  
Å  printed.  If the trace's break predicate is true as well, e. g.
Å  (THTRACE (THBKPT T T)),
Å  then THBKPT breaks in a similar fashion to THERT. (see ***).  However,
Å  THBKPT is more powerful than THERT as it also breaks upon failure backing
Å  up to it.  It is thus more useful than THERT for debugging PLANNER
Å  programs.

Å  9)  (THCOND <pair1> ... <pair n>)
Å PTHCOND is the PLANNER analogue of COND in LISP.  As in MAC-LISP the
Å  "pairs" needn't be.  Basically THCOND executes the CAR of each pair until
Å  one succeeds.  The THCOND will then succeed if all the rest of that "pair"
Å  succeeds (like a THAND) else THCOND will fail.
Å  

Å `PAGE 13

Å  10) (THCONSE <thm-name> <list-of-variables> <pattern> <body>)
Å  A planner consequent theorem can be defined and asserted by the
Å  function THCONSE.  For example,  a consequent theorem named THM1 can be
Å  defined and asserted as follows:

Å  (THCONSE THM1 (X) (FALLIBLE $?X) (THGOAL (HUMAN $?X)))

Å  This is equivalent to:

Å  (THPUTPROP
Å  'THM1
Å  '(THCONSE (X) (FALLIBLE $?X) (THGOAL (HUMAN $?X)))
Å  'THEOREM)
Å  (THASSERT THM1)

Å  The theorem name is optional.  If it is not given, a unique name is
Å  generated by the system.  Note that this feature should not be used if one
Å  later wants to erase the theorem.
Å  Asserting the theorem can be avoided by placing THNOASSERT
Å  immediately after the theorem name  For example,

Å 0(THCONSE THM1 THNOASSERT (X) (FALLIBLE $?X) (THGOAL (HUMAN $?X)))

Å  will define THM1, but not assert it.

Å  11)  (THDATA) causes Micro-Planner to go into a read loop for gobbling
Å  assertions and theorems at high speed.  Loop ends when NIL is read.

Å  12)  (THDO <e1> ... <en>)
Å PTHDO executes each of its subexpressions in turn and cares not whether
Å  they succeed or fail; it then succeeds.  More precisely, it only ignores
Å  simple failures occurring in its scope.  (For the distinction between types
Å  of failures, see THFAIL.) If a failure backs up to it, all that it did is
Å  undone.

Å  13) (THDUMP <filename1> <filename2> <device> <user>)
Å  Dumps the state of the Micro-Planner world (THSTATE) into the
Å  specified file.
Å  (THDUMP SAVE STATE) (THFLUSH) (UREAD) (IOC Q)
Å  is a no op.

Å  14)  THEOREMS
Å PTheorems are the Micro-Planner analogue of functions in LISP.  There are
Å  three kinds:

Å Pconsequent theorem - for establishing goals
Å Pantecedent theorems - for expanding on assertions
Å Perasing theorems - for expanding on erasures.


Å `PAGE 14

Å  See THCONSE, THERASING, and THANTE for a convenient method of defining
Å  theorems.  When a theorem is called the declared variables are bound and
Å  the pattern is matched to the calling pattern in THGOAL or datum in
Å  THASSERT, THERASE, and THAPPLY.  This has the effect of assigning some of
Å  the theorem's variables.  The theorem is then executed as a THPROG if the
Å  match succeeds.

Å  
Å  15)  (THERASE <skeleton> <rec1> ... <recn>)  is identical to THASSERT
Å  except for effect.  If a failure backs up to an assertion or an erasure it
Å  is undone.

Å  16)  (THERASING <thm-name> <list-of-variables> <pattern> <body>)
Å  THERASING works in a similar fashion to THCONSE to define and
Å  (optionally) assert antecedent theorems.

Å  17) (THERT <comment>)
Å  THERT causes Micro-Planner to break and print its comment.  The
Å  state of the world can be explored by EVALing any s-expression.  Planner
Å  expressions can be thvaled by explicitly calling thval.  For example,
Å  (THVAL (THASSERT (HUMAN TURING))  NIL)
Å  would add this assertion to the data base if it had not been previously
Å  asserted.  Note that explicit thvals should be done carefully as they can
Å  change the state of the world.
Å  When ready to leave the breakpoint, ($P <s-exp>) causes THERT to
Å  return the lisp value of the s-exp, (where "$" = ALT-MODE).  Note that this
Å  will cause failure if the expression evals to NIL. $P is equivalent to ($P
Å  T) and is the standard way to proceed from the breakpoint.

Å  18)  (THFAIL <arg1> <arg2> <arg3>)
Å PTHFAIL causes failure to propagate, the extent of which is determined by
Å  the arguments:
Å P(THFAIL THTAG <tag> T) causes a failure to propagate to the tag
Å  indicated.
Å P(THFAIL THTAG <tag>) causes a failure to propagate past the tag
Å  indicated.
Å P(THFAIL THPROG), (THFAIL THEOREM) cause the THPROG or the THEOREM
Å  currently in to fail.
Å P(THFAIL THMESSAGE <message>) causes a failure to propagate until it
Å  reaches a THMESSAGE statement whose pattern matches the message.
Å P(THFAIL)  causes a failure similar to the one caused by a THGOAL, say,
Å  failing.  The program will back up to the last decision point and try to
Å  patch things up.
Å  Any failure caused by THFAIL, except when it is given no arguments,
Å  is a compound failure.  All other failures are simple failures.

Å  19) (THFAIL? <predicate> <action>)
Å  If failure backs up to this planner primitive and the LISP
Å  predicate evals to true, it returns the eval of the action.  THFAIL?  is
Å  useful as a computationally less costly form of THMESSAGE since it does not

Å `PAGE 15

Å  involve pattern matching against a message failure or THPROGing.

Å  20)  (THFINALIZE <arg1> <arg2>)
Å PTHFINALIZE is a primitive which allows pruning of THTREE.  Essentially,
Å  if one THFINALIZES, say to a tag, then all the things done since that tag
Å  was passed are not undoable in case of failure.  Example:  To put all of
Å  the green blocks in the box and return a list of those actually moved:
Å  
Å P(THPROG (X (Y NIL))
Å  (THOR (THAND (THGOAL (IS $?X BLOCK))
Å P(THGOAL (COLOR $?X GREEN)))
Å `(THRETURN $?Y))
Å  FOO
Å  (THCOND ((THGOAL (CONTAIN BOX $?X)) (THFAIL))
Å  ((THGOAL (PUTIN $?X BOX) (THUSE TC-PUTIN))
Å (THSETQ $?Y (CONS $?X $?Y))
Å (THFINALIZE THTAG FOO)
Å (THFAIL))
Å  ((PRINT $?X) (THERT CAN NOT PUT IT IN))))
Å  
Å PBesides finalizing to a tag, one can finalize a theorem or a THPROG by
Å  saying (THFINALIZE THEOREM) or (THFINALIZE THPROG).  There are lots of
Å  other things that can be done with THFINALIZE, but I will not guarantee
Å  them.

Å  21)  (THFIND <mode> <skeleton> <variable declarations> <e1> ... <en>)
Å PTHFIND is a primitive whose THVALuation yields a list of objects, each
Å  of which is the result of substituting for variables in the skeleton values
Å  of those variables which cause the program starting at the variable
Å  declarations (like a THPROG) to succeed.  Thus, for example, if the data-
Å  base contained the assertions (HACKER N) (HACKER H) (HACKER RG) (AT MAC RG)
Å  and we THVALed the expression (THFIND ALL (AT SC $?X) (X) (THGOAL (HACKER
Å  $?X)) (THNOT (THGOAL (AT MAC $?X)))) we would get ((AT SC N) (AT SC H)) as
Å  its THVALUE (PLANNER value).
Å  The mode field of a THFIND may be any of the following.

Å  ALL  Says to find all items matching the description <number> Find
Å  at least that number, there may be more in the data base, but I am not
Å  interested in them.
Å  (EXACTLY <number>)  I want this number, if there are any more,
Å  fail.
Å  (AT-LEAST <number>)  If there are fewer, fail, there may be more.
Å  (AT-MOST <number>)  There may be less, but if there are more, fail.
Å  (AS-MANY-AS <number>)  I don't care how many there are (providing
Å  there is at least 1), but I only want to see <number> of them.
Å  (AT-LEAST <number1> AT-MOST <number2>)  Takes the logical "and" of
Å  the two conditions
Å  (AT-LEAST <number1> AS-MANY-AS <number2>)  Same here.

Å  Those familiar with the old version might note that this is a different

Å `PAGE 16

Å  syntax.  However, any code writen in the old form will still work on the
Å  new system.

Å  22)  (THFLUSH <indicator1> <indicator2> ...)
Å PTHFLUSH is a generally useful function for getting a LISP into some
Å  desired state.  It remprop's all properties with the indicators specified
Å  from all atoms on the OBLIST.
Å  (THFLUSH) = (THFLUSH THASSERTION THANTE THCONSE THERASING)

Å  23)  (THGO <tag>) = (THSUCCEED THTAG <tag>)

Å  24)  (THGOAL <pattern> <rec1> ... <recn>)
Å PThis is a real dilly to describe.  It is probably the most complex
Å  single primitive in Micro-Planner.  Assume the simplest case in which there
Å  are no recommendations <reci> given.  THGOAL searches the data base for a
Å  datum (i.e. an assertion) which matches the pattern.  If it finds one, it
Å  succeeds after assigning all of the unassigned variables in the pattern so
Å  as to make it match the datum;  it then returns the assertion found as its
Å  PLANNER value.  If it does not find a matching datum it fails.  If after a
Å  success, a failure propagates back to it, it unassigns the variables it
Å  assigned last time and continues its search for a matching datum from where
Å  it left off.
Å PIf recommendations are given they are tried in order.  If the very first
Å  recommendation is a (THNODB) or a (THDBF -) the initial data base
Å  
Å  
Å  search is inhibited, otherwise it is assumed in default.  The possible
Å  recommendations are:
Å p1) (THNODB) - Inhibit data base search.  If it is not first, it is
Å  useless and causes an error.
Å p2) (THDBF <filter>) -  Try only those elements of the data base
Å  satisfying the filter.
Å p3) (THTBF <filter>) - Try only those theorems satisfying the filter.
Å p4) (THUSE <th1> <th2> ...<thn>) - Try the theorems given explicitly by
Å  their atom headers in the order mentioned.
Å PA filter is any unary LISP predicate;  the always true predicate is
Å  supplied by the system as THTRUE.  All assertions have property lists which
Å  are their CDRs.  Thus if a filter refers to the CDR of its argument it is
Å  referring to the property list.  CAR of an assertion, however, is not -1 as
Å  in LISP atoms;  rather it is the datum which is matched against the
Å  pattern.
Å PIf a theorem is recommended, say with THUSE, it had better be an atom
Å  with a THEOREM property pointing to a consequent theorem (i.e. it must be
Å  of the form (THCONSE <variable declarations> <consequent> <e1> ...  <en>)).
Å  Note that the theorem need not be asserted for THUSE to apply.  If the goal
Å  pattern matches the consequent, then the theorem will be tried.  The
Å  matcher will first bind the theorem variables appearing in the declaration
Å  (see THPROG) and then match the patterns, causing some of the theorem
Å  variables to be assigned and leaving others unassigned.  If the match wins,
Å  the theorem will proceed to execute as a THPROG.  If the theorem succeeds

Å `PAGE 17

Å  the PLANNER value of the THGOAL will be the pattern of the goal with the
Å  assignments substituted for the assigned variables, unless the theorem does
Å  a THRETURN, in which case the PLANNER value of the THGOAL will be the
Å  goodie returned.  If a goal variable which is unassigned is matched against
Å  a theorem variable and the theorem eventually gives that variable a value
Å  then the goal variable also gets the value.  A more detailed description of
Å  the matcher will be given later.
Å  5)  $N <number> is a macro for (THANUM <number>).  It says that the
Å  goal should only be tried to be satisfied <number> times.  Hence the
Å  <number> + 1 'th time the goal is failed back to, no more attempts will be
Å  made and the failure will continue backwards.  In particular, $N1 can be
Å  used when there is only one possible answer, and if failure backs up to the
Å  THGOAL, no good can come by trying different assertions or theorems.  $N
Å  <number>, if it is to appear at all, must appear in the first position.
Å  6)  (THNUM <number>) is very similar to $N <number>, but may appear
Å  at any point in the recommendation list.  Its effect is to set or reset the
Å  number of times the goal will be tried. For example, if it should appear
Å  first in the list, it is, in effect saying, the goal may use any number of
Å  assertions it can find, but only <number> number of theorems.  In general,
Å  by interspersing THNUM's between recommendations, you are saying how many
Å  of the theorems which match the next filter can be tried.
Å  

Å  25) (THMATCH <exp1> <exp2>)
Å  THMATCH matches the lisp value of its first argument against the
Å  lisp value of its second argument.  For example,
Å  (THMATCH '(HUMAN TURING) '($_X $_Y))
Å  would succeed and result in $_X being assigned to 'HUMAN and $_Y being
Å  assigned to 'TURING.  If $_X were instead $?X, then THMATCH would succeed
Å  with $?X assigned to 'HUMAN, providing $?X were previously
Å  
Å  
Å  either THUNASSIGNED or assigned to HUMAN.
Å  Failing back through a THMATCH is similar to failing back through a
Å  THGOAL.  Any variable assignments made by the match are undone and the
Å  variables are returned to their previous values.
Å  Note that THMATCH will not work properly if its inputs are
Å  themselves planner functions since PLANNER is not corecursive with LISP.
Å  For example, if HUMAN TURING is already asserted, the planner value of

Å  (THGOAL (HUMAN TURING))

Å  is ((HUMAN TURING)) but its lisp value is NIL.  Hence,

Å  (THMATCH (THGOAL (H T)) '(HUMAN TURING))

Å  will not work properly.  An explicit call to THVAL, however, will work:

Å  (THMATCH
Å  (THVAL '(THGOAL (HUMAN TURING)) NIL)

Å `PAGE 18

Å  '((HUMAN TURING)))

Å  26)   (THMESSAGE <variable declarations> <pattern> <e1> . . . <en>)
Å  examines failures propagating to it, if one has a message which matches the
Å  pattern (after the declarations are made) control then passes to the body,
Å  <ei>, which executes as a THPROG.

Å  27) (THNOHASH <ATOM> <INDICATOR1> <INDICATOR2>... )
Å  The patterns of micro-planner theorems and assertions are stored in
Å  buckets hung on the atoms appearing in the patterns.  Atoms which are very
Å  common are not very useful for this purpose.  For example, suppose we
Å  wished to assert the following five patterns:

Å  A1: (JOHN IS A BOY)
Å  A2: (JACK IS A BOY)
Å  A3: (MARY IS A GIRL)
Å  A4: (JILL IS A GIRL)
Å  A5: (WOOF IS A DOG)
Å  
Å  

Å  "IS" and "A" are not helpful in distinguishing any of these assertions from
Å  the others.  It would save space as well as computation to tell planner
Å  this.  Executing

Å  (THNOHASH IS THASSERTION)
Å  (THNOHASH A  THASSERTION)

Å  accomplishes this purpose.
Å  One can be selective in telling planner where a particular atom is
Å  not useful for pattern matching purposes.  This is done by specifying which
Å  of the four following types of patterns the atom is not useful in indexing:
Å  the patterns of

Å  consequent theorems
Å  antecedent theorems
Å  erasing theorems
Å  assertions.

Å  The syntax for this is to use any combination of the four following
Å  indicators:

Å  THCONSE, THANTE, THERASING, THASSERTION

Å  For example, (THNOHASH IS THASSERTION) informs planner not to use
Å  the atom "IS" as a handle on the pattern matching of assertions in which it
Å  is found.  It is still used for pattern matching purposes when it occurs in
Å  the patterns of theorems.

Å  (THNOHASH <atom> THCONSE THANTE THERASING THASSERTION)

Å `PAGE 19

Å  can be abbreviated as (THNOHASH <atom>) and is used when the atom that it
Å  is completely useless for pattern matching purposes.

Å  28)  (THNOT <e>)  is defined as  (THCOND (<e> (THFAIL)) ((THSUCCEED))).

Å  29)  (THOR <e1> ... <en>)
Å PTHOR succeeds if at least one of its subexpressions succeeds.
Å  Basically, it CDRs down the list looking for a winner and if it finds one
Å  it succeeds, returning its value as the PLANNER value.  If a failure
Å  propagates back to it, however, it continues CDRing from the point it left
Å  off until it finds another winner or it loses.

Å  30)  (THPROG <declaration> <e1> ... <en>)
Å PTHPROG is the PLANNER equivalent of the LISP function PROG.  Its job is
Å  to bind the variables mentioned in the declaration and then to execute the
Å  expressions <ei> in sequence, unless changes in sequence are specified by
Å  tags and THGO statements.  As in LISP, atoms occurring in THPROG bodies are
Å  interpreted as tags.  If (THGO <tag>) is executed at any point in the
Å  interpretation of a THPROG, execution then proceeds from the expression
Å  immediately following the tag <tag>.  THGO statements may refer to tags
Å  which are not in the current THPROG but which are in one which called it.
Å  The execution of THPROG terminates either with a failure, successful
Å  execution of its last expression, <en>, or by a forced success with a
Å  THRETURN statement.  (THRETURN <exp>) is equivalent to (THSUCCEED THPROG
Å  <exp>) and will cause the THPROG to succeed and return as its PLANNER value
Å  the LISP value of the indicated expression.  If a THPROG returns by
Å  succeeding past the last statement, or by executing a (THSUCCEED THPROG),
Å  it returns as its PLANNER value the atom THNOVAL.  If it fails, it returns
Å  NIL.
Å PThe <declaration> is a list of variable declarations.  A variable
Å  declaration is either an atom which is the name of a variable to be used
Å  inside the THPROG, or a list of two elements, the first of which is the
Å  variable name and the second of which is a LISP expression whose LISP value
Å  is to be used as the initial value of the variable.  If a variable is bound
Å  without giving it an initial value it is given the default value
Å  "THUNASSIGNED."  A more complex form of variable declaration may be found
Å  under THRESTRICT.
Å PEvaluation of a THPROG begins at the first expression of the indicated
Å  sequence.  If it succeeds, a new branch is generated on THTREE and the next
Å  expression in sequence is evaluated, etc.  If any statement fails then the
Å  branches are unwound until either a new success ends the failure
Å  
Å  
Å  
Å  
Å  propagation or there are no more branches and the THPROG fails.  Thus
Å  THPROG behaves as a THAND with variable binding capability;  it fails
Å  unless each of its subexpressions succeeds, allowing for backup, until it
Å  returns.  As usual, any LISP expression may appear in a THPROG;  if it
Å  evaluates to NIL, a failure is generated, otherwise a success is assumed.

Å `PAGE 20

Å  Other relevant functions are THSUCCEED, THFAIL, THFINALIZE, THGO, and
Å  THRETURN.

Å  31) THPSEUDO
Å  "(THPSEUDO)" as the first recommendation to an assertion enables
Å  one to activate a pattern's antecedent theorems, without actually asserting
Å  the pattern.  For example, to activate the antecedent theorems which match
Å  the pattern "(HUMAN TURING)" without actually asserting it is accomplished
Å  by:

Å  (THASSERT (HUMAN TURING) (THPSEUDO) $T)

Å  In many cases this can be done without using THPSEUDO by first asserting
Å  the pattern with the appropriate theorem recommendations
Å  
Å  
Å  and then erasing the pattern.  For instance, one could accomplish the same
Å  effect as using THPSEUDO  in the above example by the following:

Å  (THASSERT (HUMAN TURING) $T)
Å  (THERASE (HUMAN TURING))

Å  However, THPSEUDO becomes necessary when some of the variables in the
Å  pattern are unassigned, thus preventing it from being asserted.
Å  THPSEUDO performs in the same fashion for activating a pattern's
Å  erasing theorems  without actually erasing the pattern.

Å  32)  THPUTPROP, THREMPROP, THRPLACA, THRPLACD  are just like their LISP
Å  counterparts except that if a failure backs up to them they undo their
Å  effect.

Å  33) (THRESTRICT <variable> <lisp function 1> <lisp function 2> ...)
Å  THRESTRICT allows one to restrict a PLANNER variable so that it
Å  will only match objects which satisfy the LISP predicates named in the
Å  THRESTRICT statement.  For example, consider

Å  (THGOAL (AGE MOTHER ($R $?X NUMBERP)))

Å  $R is an abbreviation, which expands to THRESTRICT. In this example, $?X
Å  will only match numbers.  Naturally, the function named must be a function
Å  of one variable.  Of course, we could have a lambda expression instead of
Å  the function name, as in

Å  (THGOAL ($?Y IS A ($R ? (LAMBDA (X) (MEMQ X '(DOG CAT HACKER))))))

Å  Also note that rather than a variable, we have a question mark inside the
Å  $R expression.  The net result is that the "?" will only match DOG, CAT, or
Å  HACKER.  However, it doesn't get assigned a value as $?X would in our first
Å  example.  We can also have


Å `PAGE 21

Å  ($R $_Z MYPRED)

Å  which has the expected result.
Å  In all our examples so far the restriction has been
Å  declared in our goal statement.  We can also create the restriction when we
Å  declare variables at the begining of a theorem, or a THPROG, as in

Å  (THPROG (A ($R B HUMANP)C)
Å  (THGOAL ($?A SON OF $?B) $T))
Å  ...)

Å  In this THPROG's variable bindings we use B rather than $?B or $_B.  (The
Å  prefix would have no meaning in the context of a variable list.) It is also
Å  possible to use THRESTRICT as a free standing function, so this last THPROG
Å  could have been written

Å  (THPROG (A B C)
Å  (THRESTRICT B HUMANP)
Å  (THGOAL ($?A SON OF $B)$T)
Å  ...)

Å  Once we restrict a variable it stays restricted until it is
Å  unbound. As we shall see, this has some interesting consequences.
Å  At the moment THGOAL is the only function which takes note of
Å  restrictions. So one can THSETQ a restricted variable to a value which
Å  would not satisfy its restrictions.  The same goes for THAMONG.
Å  It is possible to have

Å  (THPROG (A ($R B ORANGEP) C)
Å  (THGOAL (OWN $?A ($R $?B CIRCULARP)))
Å  ...)

Å  which will act the same as

Å  (THPROG (A ($R B ORANGEP CIRCULARP) C)
Å  (THGOAL (OWN $?A $?B))
Å  ...)

Å  Another interesting case is

Å  (THGOAL (OWN JACK ($R $?B CIRCULARP)) (THUSE WHOHAS))

Å  where WHOHAS looks like

Å  (THCONSE (F G)
Å  (OWN $?F $?G)
Å  (THGOAL (HOLD $?F ($R $?G SMALLP))$T))

Å  When we do this last THGOAL, the item which matches $?G must satisfy both
Å  CIRCULARP and SMALLP.  It is possible that this goal will call another

Å `PAGE 22

Å  theorem which satisfies the goal without assigning $?G a value.  If this is
Å  the case then our first goal (OWN JACK...) will be satisfied without B
Å  getting a value, but, the restriction SMALLP will stay with $?B, just as an
Å  assigned value would have.  Hence it is possible for a theorem not to
Å  assign a value to a variable, but merely restrict its range of
Å  possibilities.

Å  34)  (THRETURN <e>) = (THSUCCEED THPROG <e>)

Å  35)  (THSETQ <var1> <e1> ... <varn> <en>)
Å  Sets variable 1 to the value of e1 and ... and sets variable n to the
Å  value of en.  If failure backs up to it, it is undone.  If the variable is
Å  a planner variable then the corresponding expression is THVALed;  otherwise
Å  the expression is EVALed.  THSETQ ignores variable restrictions.  See
Å  warning about THVAL.

Å  36) (THSTATE <indicator1> <indicator2> ... )
Å  Prints that part of the state of the Micro-Planner world specified
Å  by the indicators.
Å  (THSTATE THASSERTION) = assertions in data base
Å  (THSTATE THCONSE) = consequent theorems currently asserted
Å  (THSTATE THANTE) = antecedent theorems currently asserted
Å  (THSTATE THERASING) = erasing theorems currently asserted

Å  37)  (THSUCCEED <arg1> <arg2>)
Å PTHSUCCEED caused success to propagate, the extent of which is determined
Å  by the arguments:
Å P(THSUCCEED THTAG <tag>) = (THGO <tag>) - see THPROG.
Å P(THSUCCEED THPROG <e>) = (THRETURN <e>) - see THPROG.
Å P(THSUCCEED <place>) = (THSUCCEED <place>  T)
Å  
Å  
Å P(THSUCCEED THEOREM <e>) causes theorem to succeed with value of <e>.
Å P(THSUCCEED THEOREM)  causes the theorem to succeed with value THNOVAL.
Å P(THSUCCEED) causes a simple success to propagate.

Å  38) (THUNIQUE <exp1> <exp2> ...)
Å  THUNIQUE is a state filter.  It causes failure if the list
Å  consisting of the values of its arguments has been computed by any
Å  previously executed THUNIQUE.  For example, a consequent theorem named THM1
Å  can be prevented from getting into a loop by calling itself recursively
Å  (via any intermediate theorems) with arguments identical to those supplied
Å  to the theorem at the higher level activation by making
Å  (THUNIQUE 'THM1 $?X1 $?X2 ... )
Å  the first statement of the theorem's body, where $?X1, $?X2, ... are the
Å  planner variables occurring in the theorem's pattern.

Å  39)  (THV  <variable name>)  (THNV <variable name>)
Å PThese LISP functions get the PLANNER value of the variable whose name is
Å  given.  The atoms THV and THNV also serve as markers of the special

Å `PAGE 23

Å  variable flags to the matcher.  (THV FOO) is $?FOO and (THNV FOO) is $_FOO
Å  by using the macro-character feature of LISP 1.6.

Å  40)  (THVAL <expression> <alist>)
Å PTHVAL is the Micro-Planner evaluator  just as EVAL is the LISP
Å  
Å  
Å  evaluator.  As in LISP, the first argument is evaluated (THVALuated) with
Å  free variables in it given the values associated with them on the given
Å  alist.  Micro-Planner's alist, called THALIST, is a list of pairs (CAR-
Å  CADR not CAR-CDR) of variable names and values.  If you want to stop a
Å  Micro-Planner evaluation at the next interruptable place hit ctrl-A.
Å  Planner will then type out ^A-THVAL and go into a THERT listen loop (see
Å  THERT).  The next expression to be executed is in the variable THE.  To
Å  proceed, type $p<space>.  Warning:  an explicit call to THVAL may not be
Å  reentered for backup upon failure after that call returns.

Å  41)  (THVSETQ <var1> <e1> ... <varn> <en>)
Å PSets the variables to the values of eis as in THSETQ.  Not undone on
Å  failure backup.  See warning about THVAL.

Å  42)  Abbreviations

Å  $?x  =  (THV x)
Å  $_x  =  (THNV x)
Å  $Ex =  (THEV x)
Å  $R   =  THRESTRICT
Å  $G   =  THGOAL
Å  $A   =  THASSERT
Å  $Nx =  (THANUM x)
Å  $T   =  (THTBF THTRUE)
Å  $& ... & is ignored
Å @
Å  

Å  43)  The Matcher
Å PThe Matcher in Micro-Planner is elementary and contains a minimum of
Å  bells and whistles but is (hopefully) sufficiently powerful for most
Å  problems.  Micro-Planner's matcher only matches lists one level deep and
Å  only has two distinct kinds of variable occurrences.  The matcher's actions
Å  can be summarized in the 6-by-6 chart on the next page, which shows how any
Å  two pattern elements interact.  One nice hook in the matcher is that a
Å  pattern element (or the entire pattern) may be of the form $E<expression>
Å  or (THEV <expression>) (those macro-characters are at it again!) , which
Å  means that the element (or pattern) is to be replaced with the result of
Å  THVALuating the expression with an appropriate THALIST.  For example, to
Å  stack up all red objects:

Å P(THGOAL (#STACKUP $E(THFIND ALL $?X (X) (THGOAL (#COLOR $?X #RED)) ))).


Å `PAGE 24

Å  See THRESTRICT for more powerful matching methods


Å `PAGE 25

Å  MATCHER CHARACTERISTICS


Å `PAGE 26

Å  
Å  
Å  IV.  A Compendium of Micro-Planner Error Comments
Å PThe Micro-Planner error comments are meant to be self-explanatory.  If
Å  you come across one which is not, it is probably meant for me, not you, and
Å  it would help in removing residual bugs for you to save the situation and
Å  show it to me.  All Micro-Planner error comments are typed out by a break
Å  function called THERT which leaves you in a LISP listen loop at a point as
Å  close as possible to the occurrence of the error, so that the state of the
Å  system may be interrogated.    Usually the error is fatal, but if you wish
Å  to proceed, type $P<space> (See THERT). Usually something is typed out
Å  before the error comment;  that is the object the comment is complaining
Å  about.  Micro-Planner error comments almost always end with - <funny word>;
Å  the <funny word> is the name of the system function which got mad.  In many
Å  cases, Micro - Planner will catch the error before it has done anything too
Å  drastic.  In such cases the user will be able to patch things up on the
Å  fly, and continue as if nothing happened.  Whether or not this can be done
Å  depends on the kind of error.
Å  The authorized list follows:

Å  LISPERROR - THVAL
Å PLISP became unhappy when trying to evaluate the expression typed out.
Å  If proceeded, the value of THERT will be assumed to be the value of the
Å  expression which caused the error.

Å  BAD SUCCEED - THVAL, or BAD FAIL - THVAL
Å PYou were screwed by a Planner bug.  Please save situation and contact
Å  me.

Å  UNCLEAR RECOMMENDATION - THTRY
Å PThe expression typed out before the error comment was a recommendation
Å  to THGOAL which was not either a THTBF, THDBF, THNUM, or a THUSE, or was a
Å  THANUM or THNODB which did not come first in the list.  If proceeded, the
Å  value of THERT will be assumed to be the correct recommendation.  Atomic
Å  recommendations are ignored.  Since proceeding with $P is equivalent to
Å  proceeding with the value T , $P in effect says to ignore the
Å  recommendation entirely

Å  BAD THEOREM - THTRY1
Å PThe expression printed was passed to THGOAL as a theorem.  It either did
Å  not have a THEOREM property or was not a consequent theorem.  If proceeded
Å  with a value, the value will be assumed to be the correct theorem name.  If
Å  $P is used, this theorem will be ignored and the next item on the
Å  recommendation list will be tried.

Å  BAD CALL - THFINALIZE
Å PYou called THFINALIZE without giving a place to finalize to.  If
Å  proceeded, the value of the THERT is taken as a specification of the place.
Å  If $P is used, the finalize is ignored.


Å `PAGE 27

Å  OVERPOP - THFINALIZE
Å PTHFINALIZE overpopped THTREE trying to find the lousy place to stop.
Å  This is a fatal error.  No recovery is possible.

Å  OVERPOP - THSUCCEED
Å PTHSUCCEED overpopped THTREE trying to find the place to stop succeeding.
Å  Remember that THGO and THRETURN use THSUCCEED.  Fatal error.

Å  NOT FOUND - THFAIL
Å PTHFAIL could not find the place to stop failing.  If proceeded the value
Å  of THERT is taken as a specification of the place.  If it is T or NIL then
Å  it is just returned as the value of THFAIL.

Å  IMPURE ASSERTION OR ERASURE - THASS1
Å PThe datum you tried to assert or erase had a variable which was
Å  unassigned.   The offending assertion is in the variable THX.  You may edit
Å  it to be pure and then proceed the program.

Å  BAD THEOREM - THTAE
Å PYou tried to THUSE an antecedent or erasing theorem which was of the
Å  wrong type or did not have a theorem property.  If you proceed the value of
Å  THERT is assumed to be the correct theorem name.  If you had just forgotten
Å  to define the theorem, feel free to define it before you proceed, and
Å  return the same name.

Å  UNCLEAR RECOMMENDATION - THTAE
Å  
Å  
Å PYou gave a THASSERT or THERASE recommendation which was not a THTBF or a
Å  THUSE.  As in THTRY, the value of THERT is assumed to be the corrected
Å  recommendation.  Atomic ones are again ignored.

Å  ODD NUMBER OF GOODIES - THSETQ, or ODD NUMBER OF GOODIES - THVSETQ
Å PTHSETQ or THVSETQ does not know what to do with the last goodie.
Å  Proceeding will cause the odd goodie to be ignored.  (Naturally the error
Å  will be ignored also.)

Å  THUNBOUND - THV1
Å PYou tried to access the value of the unbound variable printed.  If
Å  proceeded, the value of THERT will be assumed to be the value cell of the
Å  variable which was not bound.

Å  THUNASSIGNED - THV1
Å PYou tried to use the value of the unassigned variable printed.  The
Å  value of THERT is taken as the value of the variable in the current
Å  expression.  Note that if you want the variable to have this value later,
Å  you had better THVSETQ it.

Å  THUNBOUND - THGAL
Å PYou tried to access the unbound variable printed.  Proceed as in

Å `PAGE 28

Å  THUNBOUND - THV1.


Å `PAGE 29

Å  V.  Hints and Kinks

Å  1)Å  All atoms whose pnames begin with TH are property of Micro-Planner and
Å  should not be used in programs designed to interact with it.

Å  2)Å  When Micro-Planner is loaded (by :PLNR in DDT) it is listening in a READ-
Å  THVAL-PRINT loop at the top level.  Typing $P<space> will cause this loop
Å  to be exited to a LISP READ-EVAL-PRINT loop.  Any error condition which
Å  propagates to the top level (eg. cntrl-G) will restart the READ-THVAL-PRINT
Å  listen loop.

Å  3)Å  The system version of Micro-Planner has a LAP in it.  It is desirable to
Å  REMLAP at the earliest possible time as the LAP  takes up lots of space.

Å  4)Å  The EXPR version of Micro-Planner is in DSK:PLNR; PLNR > and the LAP
Å  version is stored in DSK:PLNR;PLNR LAP.

Å  5)Å  Because most Micro-Planner primitives operate by modifying THTREE and
Å  then returning, it is fairly unilluminating to try to trace them with a
Å  LISP tracer (which is good for the LISP  recursive control structure). For
Å  that reason I have taken pains to provide a tracer which is more relevant
Å  to the planner control structure.  It is available as EXPR code in
Å  DSK:PLNR;THTRAC >.  With it one can conditionally trace  and break on
Å  theorems, assertions, erasures, and goals.  To use the tracer one must
Å  first read it in and then incant (THTRACE <obj1> . . . <objn>), where  each
Å  object is an item to be traced or broken at.  The possible entries are
Å  either:
Å  <atom>   abbreviation for (<atom> t nil)
Å  (<atom> <trace condition>)   abbreviation for (<atom> <trace condition>
Å  nil) or
Å  (<atom> <trace condition> <break condition>)
Å  The CAR of the item may either be the name of a theorem or one of the
Å  following atoms which have special meanings:
Å  THEOREM   all theorems
Å  THGOAL   all goals
Å  THASSERT   all assertions
Å  THERASE   all erasures
Å  THBKPT   all breakpoints
Å  The conditions are THVALed with the THALIST which is current at the time of
Å  call and thus may be arbitrary PLANNER programs which test the state of
Å  variables and the data base.  Tracing of selected items, or of all items
Å  may be terminated using THUNTRACE.

Å  
Å  6)Å  A Micro-Planner program may at any point call a LISP program, but a LISP
Å  program may not call a Micro-Planner  primitive because the PLANNER control
Å  structure is not really recursive.  If a LISP routine wishes to call a
Å  PLANNER program it must explicitly THVAL it with an appropriate THALIST.
Å  Be especially careful not to screw around with the LISP values of Micro-
Å  Planner primitives unless you understand what you are doing.  The

Å `PAGE 30

Å  possibilities for lossage are infinite.

  